This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
move/
  scripts/
    deploy_a3.move
    test_setup.move
  sources/
    a3_manager.move
    creator_profile.move
    payment.move
    process_registry.move
    queue.move
    types.move
    workflow.move
  tests/
    a3_test.move
  Move.toml
src/
  agent/
    agent-service.ts
  api/
    agent-gateway.ts
    custom-agent-gateway.ts
  bin/
    a3.ts
  cli/
    index.ts
    register-process-cli.ts
    register-process-command.ts
  contract/
    aptos-contract-service.ts
    interfaces.ts
  creator/
    interfaces.ts
  discovery/
    aptos/
      deploy-contract.ts
      discovery-service.ts
      example-client.ts
      factory.ts
      index.ts
      Move.toml
      process_registry.move
      README.md
      setup.ts
      test-contract.ts
    aptos-discovery-service.ts
    index.ts
    interfaces.ts
    process-discovery-service.ts
  payment/
    aptos-payment-service.ts
    interfaces.ts
    payment-service.ts
  process/
    extended-process.ts
    index.ts
  transaction/
    transaction-handler.ts
  utils/
    constants.ts
    env-validator.ts
    index.ts
    logger.ts
  factories.ts
  index.ts
.eslintrc.js
.gitignore
deploy-contract.ts
get-process.ts
list-processes.ts
package.json
register-process.ts
run-process-with-payment.ts
server.ts
setup-aptos.sh
tsconfig.json

================================================================
Files
================================================================

================
File: move/scripts/deploy_a3.move
================
script {
    use a3::a3_manager;
    
    /// Deploy and initialize the A3 system
    public entry fun deploy_a3(
        admin: &signer,
        protocol_fee_percentage: u64,
        protocol_fee_recipient: address
    ) {
        // Initialize the A3 system
        a3_manager::initialize(
            admin, 
            protocol_fee_percentage, 
            protocol_fee_recipient
        );
    }
}

================
File: move/scripts/test_setup.move
================
script {
    use std::string;
    use std::vector;
    use std::signer;
    use a3::a3_manager;
    use a3::creator_profile;
    use a3::process_registry;
    use a3::workflow;
    use a3::queue;
    
    /// Create a test environment for the A3 system 
    public entry fun test_setup(
        admin: &signer,
        creator: &signer,
        user: &signer
    ) {
        let admin_addr = signer::address_of(admin);
        let creator_addr = signer::address_of(creator);
        
        // Initialize the system
        a3_manager::initialize(admin, 100, admin_addr); // 1% fee to admin
        
        // Create a creator profile
        let name_str = string::utf8(b"Test Creator");
        let description_str = string::utf8(b"A test creator for the A3 system");
        let social_links = vector::empty<string::String>();
        
        creator_profile::create_profile(
            creator,
            name_str,
            description_str,
            creator_addr,
            social_links
        );
        
        // Register a process
        let process_id_str = string::utf8(b"process_1");
        let name_str = string::utf8(b"Test Process");
        let description_str = string::utf8(b"A test process for the A3 system");
        
        let tags_str = vector::empty<string::String>();
        vector::push_back(&mut tags_str, string::utf8(b"test"));
        vector::push_back(&mut tags_str, string::utf8(b"demo"));
        
        process_registry::register_process(
            creator,
            process_id_str,
            name_str,
            description_str,
            vector::empty(), // No agents initially
            vector::empty(), // No workflows initially
            tags_str
        );
        
        // Create a workflow
        let workflow_id_str = string::utf8(b"workflow_1");
        let name_str = string::utf8(b"Test Workflow");
        let description_str = string::utf8(b"A test workflow for the process");
        
        workflow::create_workflow(
            creator,
            workflow_id_str,
            name_str,
            description_str
        );
        
        // Add workflow to process
        process_registry::add_workflow(
            creator,
            process_id_str,
            workflow_id_str
        );
        
        // Add a task to the workflow
        workflow::add_task(
            creator,
            workflow_id_str,
            string::utf8(b"task_1"),
            string::utf8(b"Test Task"),
            string::utf8(b"A test task for the workflow"),
            creator_addr,
            vector::empty() // No dependencies
        );
        
        // Initialize a queue for the creator
        queue::initialize_queue(
            creator,
            string::utf8(b"Creator Queue"),
            5
        );
        
        // User submits a transaction to the queue
        queue::submit_transaction(
            user,
            process_id_str,
            string::utf8(b"tx_1"),
            option::some(workflow_id_str),
            option::some(string::utf8(b"task_1")),
            1, // normal priority
            vector[0, 1, 2, 3] // sample data
        );
    }
}

================
File: move/sources/a3_manager.move
================
module a3::a3_manager {
    use std::string::{String};
    use std::signer;
    use std::error;
    use aptos_framework::account;
    use aptos_framework::timestamp;
    use a3::creator_profile;
    use a3::process_registry;
    use a3::payment;
    use a3::workflow;
    use a3::queue;
    
    /// Errors
    const E_NOT_AUTHORIZED: u64 = 1;
    const E_NOT_INITIALIZED: u64 = 2;
    const E_ALREADY_INITIALIZED: u64 = 3;
    
    /// Configuration for the A3 system
    struct A3Config has key {
        admin: address,
        protocol_fee_percentage: u64, // in basis points (1% = 100)
        protocol_fee_recipient: address,
        initialized_at: u64,
        updated_at: u64,
    }
    
    /// Initialize the A3 system
    public entry fun initialize(
        account: &signer,
        protocol_fee_percentage: u64,
        protocol_fee_recipient: address
    ) {
        let account_addr = signer::address_of(account);
        
        // Only the module publisher can initialize
        assert!(account_addr == @a3, error::permission_denied(E_NOT_AUTHORIZED));
        
        // Check if already initialized
        assert!(!exists<A3Config>(account_addr), error::already_exists(E_ALREADY_INITIALIZED));
        
        let current_time = timestamp::now_seconds();
        
        // Create config
        let config = A3Config {
            admin: account_addr,
            protocol_fee_percentage,
            protocol_fee_recipient,
            initialized_at: current_time,
            updated_at: current_time,
        };
        
        // Store config
        move_to(account, config);
        
        // Initialize all sub-modules
        creator_profile::initialize(account);
        process_registry::initialize(account);
        payment::initialize(account);
        workflow::initialize(account);
        queue::initialize_queue(account, String::utf8(b"Main Queue"), 10);
    }
    
    /// Update protocol fee settings
    public entry fun update_protocol_fee(
        account: &signer,
        new_fee_percentage: u64,
        new_fee_recipient: address
    ) {
        let account_addr = signer::address_of(account);
        
        // Check if initialized
        assert!(exists<A3Config>(@a3), error::not_found(E_NOT_INITIALIZED));
        
        // Get config
        let config = borrow_global_mut<A3Config>(@a3);
        
        // Check authorization
        assert!(account_addr == config.admin, error::permission_denied(E_NOT_AUTHORIZED));
        
        // Update fee settings
        config.protocol_fee_percentage = new_fee_percentage;
        config.protocol_fee_recipient = new_fee_recipient;
        config.updated_at = timestamp::now_seconds();
    }
    
    /// Transfer admin rights
    public entry fun transfer_admin(
        account: &signer,
        new_admin: address
    ) {
        let account_addr = signer::address_of(account);
        
        // Check if initialized
        assert!(exists<A3Config>(@a3), error::not_found(E_NOT_INITIALIZED));
        
        // Get config
        let config = borrow_global_mut<A3Config>(@a3);
        
        // Check authorization
        assert!(account_addr == config.admin, error::permission_denied(E_NOT_AUTHORIZED));
        
        // Update admin
        config.admin = new_admin;
        config.updated_at = timestamp::now_seconds();
    }
    
    /// Register as a creator and register a process in one transaction
    public entry fun register_creator_and_process(
        account: &signer,
        creator_name: String,
        creator_description: String,
        social_links: vector<String>,
        process_id: String,
        process_name: String,
        process_description: String,
        tags: vector<String>
    ) {
        let sender_addr = signer::address_of(account);
        
        // Register creator profile if doesn't exist
        if (!creator_profile::profile_exists(sender_addr)) {
            creator_profile::create_profile(
                account,
                creator_name,
                creator_description,
                sender_addr,
                social_links
            );
        };
        
        // Register process
        process_registry::register_process(
            account,
            process_id,
            process_name,
            process_description,
            vector::empty(), // No agents initially
            vector::empty(), // No workflows initially
            tags
        );
    }
    
    /// Create a process workflow
    public entry fun create_process_workflow(
        account: &signer,
        process_id: String,
        workflow_id: String,
        workflow_name: String,
        workflow_description: String
    ) {
        // Check if process exists and user is owner
        assert!(process_registry::process_exists(process_id), error::not_found(E_NOT_INITIALIZED));
        let (_, _, process_owner, _, _, _, _, _, _, _) = process_registry::get_process(process_id);
        assert!(process_owner == signer::address_of(account), error::permission_denied(E_NOT_AUTHORIZED));
        
        // Create workflow
        workflow::create_workflow(
            account,
            workflow_id,
            workflow_name,
            workflow_description
        );
        
        // Add workflow to process
        process_registry::add_workflow(account, process_id, workflow_id);
    }
    
    /// Execute a process with payment
    public entry fun execute_process_with_payment(
        account: &signer,
        process_id: String,
        transaction_id: String,
        amount: u64,
        priority: u8,
        data: vector<u8>
    ) {
        // Make payment first
        payment::make_payment(account, process_id, amount);
        
        // Submit transaction to queue
        queue::submit_transaction(
            account,
            process_id,
            transaction_id,
            option::none(), // No specific workflow
            option::none(), // No specific task
            priority,
            data
        );
    }
    
    /// Get protocol fee information
    public fun get_protocol_fee_info(): (u64, address) {
        assert!(exists<A3Config>(@a3), error::not_found(E_NOT_INITIALIZED));
        
        let config = borrow_global<A3Config>(@a3);
        (config.protocol_fee_percentage, config.protocol_fee_recipient)
    }
}

================
File: move/sources/creator_profile.move
================
module a3::creator_profile {
    use std::string::{String};
    use std::signer;
    use std::error;
    use aptos_framework::event;
    use aptos_framework::account;
    use a3::types::{SocialLinks};
    
    /// Errors
    const E_NOT_AUTHORIZED: u64 = 1;
    const E_PROFILE_NOT_FOUND: u64 = 2;
    const E_PROFILE_ALREADY_EXISTS: u64 = 3;

    /// Creator profile
    struct CreatorProfile has key, store {
        name: String,
        description: String,
        wallet_address: address,
        social_links: SocialLinks,
        registration_time: u64,
        last_updated: u64,
    }
    
    /// Resource to store creator profiles by their ID
    struct CreatorProfileStore has key {
        profiles: vector<CreatorProfile>,
    }
    
    /// Events
    struct ProfileCreatedEvent has drop, store {
        creator_address: address,
        name: String,
        timestamp: u64,
    }
    
    struct ProfileUpdatedEvent has drop, store {
        creator_address: address,
        name: String,
        timestamp: u64,
    }
    
    /// Initialize module with empty profile store
    public entry fun initialize(account: &signer) {
        let account_addr = signer::address_of(account);
        if (!exists<CreatorProfileStore>(account_addr)) {
            move_to(account, CreatorProfileStore {
                profiles: vector::empty<CreatorProfile>(),
            });
        };
    }
    
    /// Create a new creator profile
    public entry fun create_profile(
        account: &signer,
        name: String,
        description: String,
        social_twitter: String,
        social_discord: String,
        social_telegram: String,
        social_website: String
    ) {
        let account_addr = signer::address_of(account);
        
        // Check if profile already exists
        assert!(!has_profile(account_addr), error::already_exists(E_PROFILE_ALREADY_EXISTS));
        
        // Create social links
        let social_links = a3::types::create_social_links(
            social_twitter,
            social_discord,
            social_telegram,
            social_website
        );
        
        // Create and store the profile
        let current_time = aptos_framework::timestamp::now_seconds();
        let new_profile = CreatorProfile {
            name,
            description,
            wallet_address: account_addr,
            social_links,
            registration_time: current_time,
            last_updated: current_time,
        };
        
        // Add profile to store
        if (!exists<CreatorProfileStore>(account_addr)) {
            move_to(account, CreatorProfileStore {
                profiles: vector::singleton(new_profile),
            });
        } else {
            let store = borrow_global_mut<CreatorProfileStore>(account_addr);
            vector::push_back(&mut store.profiles, new_profile);
        };
        
        // Emit event
        event::emit(ProfileCreatedEvent {
            creator_address: account_addr,
            name,
            timestamp: current_time,
        });
    }
    
    /// Update an existing creator profile
    public entry fun update_profile(
        account: &signer,
        name: String,
        description: String,
        social_twitter: String,
        social_discord: String,
        social_telegram: String,
        social_website: String
    ) {
        let account_addr = signer::address_of(account);
        
        // Check if profile exists
        assert!(has_profile(account_addr), error::not_found(E_PROFILE_NOT_FOUND));
        
        // Get profile
        let store = borrow_global_mut<CreatorProfileStore>(account_addr);
        let profile_idx = find_profile_index(&store.profiles, account_addr);
        assert!(profile_idx < vector::length(&store.profiles), error::not_found(E_PROFILE_NOT_FOUND));
        
        let profile = vector::borrow_mut(&mut store.profiles, profile_idx);
        
        // Update profile
        profile.name = name;
        profile.description = description;
        profile.social_links = a3::types::create_social_links(
            social_twitter,
            social_discord,
            social_telegram,
            social_website
        );
        profile.last_updated = aptos_framework::timestamp::now_seconds();
        
        // Emit event
        event::emit(ProfileUpdatedEvent {
            creator_address: account_addr,
            name,
            timestamp: profile.last_updated,
        });
    }
    
    /// Check if an address has a creator profile
    public fun has_profile(addr: address): bool {
        exists<CreatorProfileStore>(addr) && 
        find_profile_index(&borrow_global<CreatorProfileStore>(addr).profiles, addr) < 
        vector::length(&borrow_global<CreatorProfileStore>(addr).profiles)
    }
    
    /// Get creator profile (read-only)
    public fun get_profile(addr: address): (String, String, address, SocialLinks, u64, u64) {
        assert!(has_profile(addr), error::not_found(E_PROFILE_NOT_FOUND));
        
        let store = borrow_global<CreatorProfileStore>(addr);
        let profile_idx = find_profile_index(&store.profiles, addr);
        let profile = vector::borrow(&store.profiles, profile_idx);
        
        (
            profile.name,
            profile.description,
            profile.wallet_address,
            profile.social_links,
            profile.registration_time,
            profile.last_updated
        )
    }
    
    /// Helper function to find profile index in the vector
    fun find_profile_index(profiles: &vector<CreatorProfile>, addr: address): u64 {
        let i = 0;
        let len = vector::length(profiles);
        
        while (i < len) {
            let profile = vector::borrow(profiles, i);
            if (profile.wallet_address == addr) {
                return i
            };
            i = i + 1;
        };
        
        len // Return length if not found (will be handled as not found)
    }
}

================
File: move/sources/payment.move
================
module a3::payment {
    use std::string::{String};
    use std::signer;
    use std::error;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    use aptos_framework::event;
    use aptos_framework::timestamp;
    use a3::process_registry;
    
    /// Errors
    const E_NOT_AUTHORIZED: u64 = 1;
    const E_PROCESS_NOT_FOUND: u64 = 2;
    const E_INSUFFICIENT_BALANCE: u64 = 3;
    const E_PAYMENT_ALREADY_MADE: u64 = 4;
    const E_PAYMENT_NOT_REQUIRED: u64 = 5;
    const E_PAYMENT_NOT_FOUND: u64 = 6;
    const E_TASK_NOT_COMPLETED: u64 = 7;
    const E_PAYMENT_ALREADY_RELEASED: u64 = 8;
    
    /// Payment record
    struct Payment has key, store {
        process_id: String,
        task_id: String,
        payer: address,
        receiver: address,
        amount: u64,
        currency: String,
        status: u8, // 1 = escrow, 2 = completed, 3 = refunded
        payment_time: u64,
        expiration_time: u64,
    }
    
    /// Payment status constants
    const PAYMENT_STATUS_ESCROW: u8 = 1;
    const PAYMENT_STATUS_COMPLETED: u8 = 2;
    const PAYMENT_STATUS_REFUNDED: u8 = 3;
    
    /// Escrow resource to hold funds
    struct Escrow has key {
        coins: coin::Coin<AptosCoin>
    }
    
    /// Resource to store all payments
    struct PaymentStore has key {
        payments: vector<Payment>,
    }
    
    /// Events
    struct PaymentCreatedEvent has drop, store {
        process_id: String,
        task_id: String,
        payer: address,
        receiver: address,
        amount: u64,
        timestamp: u64,
    }
    
    struct PaymentCompletedEvent has drop, store {
        process_id: String,
        task_id: String,
        payer: address,
        receiver: address,
        amount: u64,
        timestamp: u64,
    }
    
    struct PaymentRefundedEvent has drop, store {
        process_id: String,
        task_id: String,
        payer: address,
        receiver: address,
        amount: u64,
        timestamp: u64,
    }
    
    /// Initialize module
    public entry fun initialize(account: &signer) {
        let account_addr = signer::address_of(account);
        if (!exists<PaymentStore>(account_addr)) {
            move_to(account, PaymentStore {
                payments: vector::empty<Payment>(),
            });
        };
    }
    
    /// Make a payment for a process that will be held in escrow
    public entry fun make_payment(
        account: &signer,
        process_id: String,
        task_id: String,
        amount: u64
    ) {
        let payer_addr = signer::address_of(account);
        
        // Check process exists and get owner
        assert!(process_registry::process_exists(process_id), error::not_found(E_PROCESS_NOT_FOUND));
        
        // Get process details to check pricing
        let (_, _, owner_addr, _, _, _, _, pricing_option, _, _) = process_registry::get_process(process_id);
        
        // Check if process requires payment
        assert!(option::is_some(&pricing_option), error::invalid_argument(E_PAYMENT_NOT_REQUIRED));
        
        let pricing = option::borrow(&pricing_option);
        let required_amount = pricing.task_price;
        let currency = pricing.currency;
        let requires_prepayment = pricing.requires_prepayment;
        
        // Check if prepayment is required
        assert!(requires_prepayment, error::invalid_argument(E_PAYMENT_NOT_REQUIRED));
        
        // Check if user has enough balance
        assert!(coin::balance<AptosCoin>(payer_addr) >= amount, error::invalid_state(E_INSUFFICIENT_BALANCE));
        
        // Check amount matches required amount
        assert!(amount >= required_amount, error::invalid_argument(E_INSUFFICIENT_BALANCE));
        
        // Check if payment already exists
        assert!(!payment_exists(process_id, task_id, payer_addr), error::already_exists(E_PAYMENT_ALREADY_MADE));
        
        // Withdraw funds from user and store in module escrow
        let escrow_coins = coin::withdraw<AptosCoin>(account, amount);
        
        // Store escrow under A3 module account
        if (!exists<Escrow>(@a3)) {
            let a3_account = account::create_signer_with_capability(
                &account::create_test_signer_cap(@a3)
            );
            move_to(&a3_account, Escrow { coins: escrow_coins });
        } else {
            let escrow = borrow_global_mut<Escrow>(@a3);
            coin::merge(&mut escrow.coins, escrow_coins);
        };
        
        // Create payment record
        let current_time = timestamp::now_seconds();
        let expiration_time = current_time + 604800; // 7 days expiration
        
        let payment = Payment {
            process_id,
            task_id,
            payer: payer_addr,
            receiver: owner_addr,
            amount,
            currency,
            status: PAYMENT_STATUS_ESCROW, // Mark as in escrow initially
            payment_time: current_time,
            expiration_time,
        };
        
        // Store payment
        if (!exists<PaymentStore>(@a3)) {
            let a3_account = account::create_signer_with_capability(
                &account::create_test_signer_cap(@a3)
            );
            move_to(&a3_account, PaymentStore {
                payments: vector::singleton(payment),
            });
        } else {
            let store = borrow_global_mut<PaymentStore>(@a3);
            vector::push_back(&mut store.payments, payment);
        };
        
        // Emit event
        event::emit(PaymentCreatedEvent {
            process_id,
            task_id,
            payer: payer_addr,
            receiver: owner_addr,
            amount,
            timestamp: current_time,
        });
    }
    
    /// Release payment from escrow after task completion and approval
    public entry fun release_payment(
        account: &signer,
        process_id: String,
        task_id: String
    ) {
        let payer_addr = signer::address_of(account);
        
        // Check payment exists
        assert!(payment_exists(process_id, task_id, payer_addr), error::not_found(E_PAYMENT_NOT_FOUND));
        
        // Get payment
        let store = borrow_global_mut<PaymentStore>(@a3);
        let payment_idx = find_payment_index(&store.payments, process_id, task_id, payer_addr);
        let payment = vector::borrow_mut(&mut store.payments, payment_idx);
        
        // Check payment is still in escrow
        assert!(payment.status == PAYMENT_STATUS_ESCROW, error::invalid_state(E_PAYMENT_ALREADY_RELEASED));
        
        // Get the funds from escrow
        let escrow = borrow_global_mut<Escrow>(@a3);
        let amount_to_release = payment.amount;
        let receiver_addr = payment.receiver;
        
        // Check if escrow has enough funds
        assert!(coin::value(&escrow.coins) >= amount_to_release, error::invalid_state(E_INSUFFICIENT_BALANCE));
        
        // Extract funds from escrow
        let coins_to_send = coin::extract(&mut escrow.coins, amount_to_release);
        
        // Update payment status
        payment.status = PAYMENT_STATUS_COMPLETED;
        
        // Transfer funds to receiver
        let receiver_account = account::create_signer_with_capability(
            &account::create_test_signer_cap(receiver_addr)
        );
        coin::deposit(receiver_addr, coins_to_send);
        
        // Emit event
        event::emit(PaymentCompletedEvent {
            process_id: payment.process_id,
            task_id: payment.task_id,
            payer: payment.payer,
            receiver: payment.receiver,
            amount: payment.amount,
            timestamp: timestamp::now_seconds(),
        });
    }
    
    /// Request refund for a payment
    public entry fun request_refund(
        account: &signer,
        process_id: String,
        task_id: String
    ) {
        let payer_addr = signer::address_of(account);
        
        // Check payment exists
        assert!(payment_exists(process_id, task_id, payer_addr), error::not_found(E_PAYMENT_NOT_FOUND));
        
        // Get payment
        let store = borrow_global_mut<PaymentStore>(@a3);
        let payment_idx = find_payment_index(&store.payments, process_id, task_id, payer_addr);
        let payment = vector::borrow_mut(&mut store.payments, payment_idx);
        
        // Check if payment is not already refunded
        assert!(payment.status != PAYMENT_STATUS_REFUNDED, error::invalid_state(E_PAYMENT_ALREADY_MADE));
        
        // Check if payment is still in escrow
        assert!(payment.status == PAYMENT_STATUS_ESCROW, error::invalid_state(E_PAYMENT_ALREADY_RELEASED));
        
        // Check if within refund period
        let current_time = timestamp::now_seconds();
        assert!(current_time <= payment.expiration_time, error::invalid_state(E_NOT_AUTHORIZED));
        
        // Get the funds from escrow
        let escrow = borrow_global_mut<Escrow>(@a3);
        let amount_to_refund = payment.amount;
        
        // Check if escrow has enough funds
        assert!(coin::value(&escrow.coins) >= amount_to_refund, error::invalid_state(E_INSUFFICIENT_BALANCE));
        
        // Extract funds from escrow
        let coins_to_refund = coin::extract(&mut escrow.coins, amount_to_refund);
        
        // Update payment status
        payment.status = PAYMENT_STATUS_REFUNDED;
        
        // Transfer funds back to payer
        coin::deposit(payer_addr, coins_to_refund);
        
        // Emit event
        event::emit(PaymentRefundedEvent {
            process_id: payment.process_id,
            task_id: payment.task_id,
            payer: payment.payer,
            receiver: payment.receiver,
            amount: payment.amount,
            timestamp: current_time,
        });
    }
    
    /// Verify if payment has been made for a process and task
    public fun verify_payment(process_id: String, task_id: String, payer_addr: address): bool {
        if (!exists<PaymentStore>(@a3)) {
            return false
        };
        
        let store = borrow_global<PaymentStore>(@a3);
        let payment_idx = find_payment_index(&store.payments, process_id, task_id, payer_addr);
        
        if (payment_idx >= vector::length(&store.payments)) {
            return false
        };
        
        let payment = vector::borrow(&store.payments, payment_idx);
        payment.status == PAYMENT_STATUS_ESCROW || payment.status == PAYMENT_STATUS_COMPLETED
    }
    
    /// Check if a payment exists
    public fun payment_exists(process_id: String, task_id: String, payer_addr: address): bool {
        if (!exists<PaymentStore>(@a3)) {
            return false
        };
        
        let store = borrow_global<PaymentStore>(@a3);
        find_payment_index(&store.payments, process_id, task_id, payer_addr) < vector::length(&store.payments)
    }
    
    /// Get payment details
    public fun get_payment(process_id: String, task_id: String, payer_addr: address): (
        String, String, address, address, u64, String, u8, u64, u64
    ) {
        assert!(payment_exists(process_id, task_id, payer_addr), error::not_found(E_PAYMENT_NOT_FOUND));
        
        let store = borrow_global<PaymentStore>(@a3);
        let payment_idx = find_payment_index(&store.payments, process_id, task_id, payer_addr);
        let payment = vector::borrow(&store.payments, payment_idx);
        
        (
            payment.process_id,
            payment.task_id,
            payment.payer,
            payment.receiver,
            payment.amount,
            payment.currency,
            payment.status,
            payment.payment_time,
            payment.expiration_time
        )
    }
    
    /// Helper function to find payment index in the vector
    fun find_payment_index(payments: &vector<Payment>, process_id: String, task_id: String, payer: address): u64 {
        let i = 0;
        let len = vector::length(payments);
        
        while (i < len) {
            let payment = vector::borrow(payments, i);
            if (payment.process_id == process_id && payment.task_id == task_id && payment.payer == payer) {
                return i
            };
            i = i + 1;
        };
        
        len // Return length if not found (will be handled as not found)
    }
}

================
File: move/sources/process_registry.move
================
module a3::process_registry {
    use std::string::{String};
    use std::vector;
    use std::signer;
    use std::error;
    use aptos_framework::event;
    use aptos_framework::timestamp;
    use a3::types::{Agent, Workflow, Pricing};
    use a3::creator_profile;
    
    /// Errors
    const E_NOT_AUTHORIZED: u64 = 1;
    const E_PROCESS_NOT_FOUND: u64 = 2;
    const E_PROCESS_ALREADY_EXISTS: u64 = 3;
    
    /// Process status enum
    const STATUS_ACTIVE: u8 = 1;
    const STATUS_INACTIVE: u8 = 2;
    const STATUS_ERROR: u8 = 3;
    
    /// Process metadata
    struct Process has key, store {
        id: String,
        name: String,
        description: String,
        owner: address,
        agents: vector<Agent>,
        workflows: vector<Workflow>,
        tags: vector<String>,
        status: u8,
        pricing: Option<Pricing>,
        created_at: u64,
        updated_at: u64,
    }
    
    /// Resource to store all processes
    struct ProcessRegistry has key {
        processes: vector<Process>,
    }
    
    /// Events
    struct ProcessRegisteredEvent has drop, store {
        process_id: String,
        owner: address,
        timestamp: u64,
    }
    
    struct ProcessUpdatedEvent has drop, store {
        process_id: String,
        owner: address,
        timestamp: u64,
    }
    
    struct ProcessDeregisteredEvent has drop, store {
        process_id: String,
        owner: address,
        timestamp: u64,
    }
    
    /// Initialize module
    public entry fun initialize(account: &signer) {
        let account_addr = signer::address_of(account);
        if (!exists<ProcessRegistry>(account_addr)) {
            move_to(account, ProcessRegistry {
                processes: vector::empty<Process>(),
            });
        };
    }
    
    /// Register a new process
    public entry fun register_process(
        account: &signer,
        id: String,
        name: String,
        description: String,
        tags: vector<String>,
        has_pricing: bool,
        task_price: u64,
        currency: String,
        requires_prepayment: bool
    ) {
        let account_addr = signer::address_of(account);
        
        // Verify creator has a profile
        assert!(creator_profile::has_profile(account_addr), error::not_found(E_NOT_AUTHORIZED));
        
        // Check process doesn't already exist
        assert!(!process_exists(id), error::already_exists(E_PROCESS_ALREADY_EXISTS));
        
        // Create process
        let current_time = timestamp::now_seconds();
        
        // Create pricing if requested
        let pricing = if (has_pricing) {
            option::some(a3::types::create_pricing(
                task_price,
                currency,
                account_addr, // Payment address is the owner's address
                requires_prepayment
            ))
        } else {
            option::none<Pricing>()
        };
        
        let process = Process {
            id,
            name,
            description,
            owner: account_addr,
            agents: vector::empty<Agent>(),
            workflows: vector::empty<Workflow>(),
            tags,
            status: STATUS_ACTIVE,
            pricing,
            created_at: current_time,
            updated_at: current_time,
        };
        
        // Get registry and add process
        let registry = borrow_global_mut<ProcessRegistry>(@a3);
        vector::push_back(&mut registry.processes, process);
        
        // Emit event
        event::emit(ProcessRegisteredEvent {
            process_id: id,
            owner: account_addr,
            timestamp: current_time,
        });
    }
    
    /// Update an existing process
    public entry fun update_process(
        account: &signer,
        id: String,
        name: String,
        description: String,
        tags: vector<String>,
        status: u8,
        has_pricing: bool,
        task_price: u64,
        currency: String,
        requires_prepayment: bool
    ) {
        let account_addr = signer::address_of(account);
        
        // Check process exists
        assert!(process_exists(id), error::not_found(E_PROCESS_NOT_FOUND));
        
        // Get registry
        let registry = borrow_global_mut<ProcessRegistry>(@a3);
        
        // Find process
        let process_idx = find_process_index(&registry.processes, &id);
        let process = vector::borrow_mut(&mut registry.processes, process_idx);
        
        // Check ownership
        assert!(process.owner == account_addr, error::permission_denied(E_NOT_AUTHORIZED));
        
        // Update process
        process.name = name;
        process.description = description;
        process.tags = tags;
        process.status = status;
        
        // Update pricing
        if (has_pricing) {
            process.pricing = option::some(a3::types::create_pricing(
                task_price,
                currency,
                account_addr, // Payment address is the owner's address
                requires_prepayment
            ));
        } else {
            process.pricing = option::none<Pricing>();
        };
        
        process.updated_at = timestamp::now_seconds();
        
        // Emit event
        event::emit(ProcessUpdatedEvent {
            process_id: id,
            owner: account_addr,
            timestamp: process.updated_at,
        });
    }
    
    /// Add an agent to a process
    public entry fun add_agent(
        account: &signer,
        process_id: String,
        agent_id: String,
        agent_name: String,
        instructions: String,
        goal: String,
        role: String
    ) {
        let account_addr = signer::address_of(account);
        
        // Check process exists
        assert!(process_exists(process_id), error::not_found(E_PROCESS_NOT_FOUND));
        
        // Get registry
        let registry = borrow_global_mut<ProcessRegistry>(@a3);
        
        // Find process
        let process_idx = find_process_index(&registry.processes, &process_id);
        let process = vector::borrow_mut(&mut registry.processes, process_idx);
        
        // Check ownership
        assert!(process.owner == account_addr, error::permission_denied(E_NOT_AUTHORIZED));
        
        // Create and add agent
        let agent = a3::types::create_agent(agent_id, agent_name, instructions, goal, role);
        vector::push_back(&mut process.agents, agent);
        
        // Update timestamp
        process.updated_at = timestamp::now_seconds();
    }
    
    /// Add a workflow to a process
    public entry fun add_workflow(
        account: &signer,
        process_id: String,
        workflow_id: String,
        workflow_name: String,
        workflow_description: String
    ) {
        let account_addr = signer::address_of(account);
        
        // Check process exists
        assert!(process_exists(process_id), error::not_found(E_PROCESS_NOT_FOUND));
        
        // Get registry
        let registry = borrow_global_mut<ProcessRegistry>(@a3);
        
        // Find process
        let process_idx = find_process_index(&registry.processes, &process_id);
        let process = vector::borrow_mut(&mut registry.processes, process_idx);
        
        // Check ownership
        assert!(process.owner == account_addr, error::permission_denied(E_NOT_AUTHORIZED));
        
        // Create and add workflow
        let workflow = a3::types::create_workflow(
            workflow_id, 
            workflow_name, 
            workflow_description
        );
        vector::push_back(&mut process.workflows, workflow);
        
        // Update timestamp
        process.updated_at = timestamp::now_seconds();
    }
    
    /// Deregister an existing process
    public entry fun deregister_process(account: &signer, id: String) {
        let account_addr = signer::address_of(account);
        
        // Check process exists
        assert!(process_exists(id), error::not_found(E_PROCESS_NOT_FOUND));
        
        // Get registry
        let registry = borrow_global_mut<ProcessRegistry>(@a3);
        
        // Find process
        let process_idx = find_process_index(&registry.processes, &id);
        let process = vector::borrow(&registry.processes, process_idx);
        
        // Check ownership
        assert!(process.owner == account_addr, error::permission_denied(E_NOT_AUTHORIZED));
        
        // Remove process
        let _removed_process = vector::remove(&mut registry.processes, process_idx);
        
        // Emit event
        event::emit(ProcessDeregisteredEvent {
            process_id: id,
            owner: account_addr,
            timestamp: timestamp::now_seconds(),
        });
    }
    
    /// Check if a process exists
    public fun process_exists(id: String): bool {
        if (!exists<ProcessRegistry>(@a3)) {
            return false
        };
        
        let registry = borrow_global<ProcessRegistry>(@a3);
        find_process_index(&registry.processes, &id) < vector::length(&registry.processes)
    }
    
    /// Get process details
    public fun get_process(id: String): (
        String, String, address, vector<Agent>, vector<Workflow>, 
        vector<String>, u8, Option<Pricing>, u64, u64
    ) {
        assert!(process_exists(id), error::not_found(E_PROCESS_NOT_FOUND));
        
        let registry = borrow_global<ProcessRegistry>(@a3);
        let process_idx = find_process_index(&registry.processes, &id);
        let process = vector::borrow(&registry.processes, process_idx);
        
        (
            process.id,
            process.name,
            process.owner,
            process.agents,
            process.workflows,
            process.tags,
            process.status,
            process.pricing,
            process.created_at,
            process.updated_at
        )
    }
    
    /// List processes owned by a specific address
    public fun list_processes_by_owner(owner: address): vector<String> {
        if (!exists<ProcessRegistry>(@a3)) {
            return vector::empty<String>()
        };
        
        let registry = borrow_global<ProcessRegistry>(@a3);
        let result = vector::empty<String>();
        
        let i = 0;
        let len = vector::length(&registry.processes);
        
        while (i < len) {
            let process = vector::borrow(&registry.processes, i);
            if (process.owner == owner) {
                vector::push_back(&mut result, process.id);
            };
            i = i + 1;
        };
        
        result
    }
    
    /// List processes by tag
    public fun list_processes_by_tag(tag: String): vector<String> {
        if (!exists<ProcessRegistry>(@a3)) {
            return vector::empty<String>()
        };
        
        let registry = borrow_global<ProcessRegistry>(@a3);
        let result = vector::empty<String>();
        
        let i = 0;
        let len = vector::length(&registry.processes);
        
        while (i < len) {
            let process = vector::borrow(&registry.processes, i);
            if (a3::types::vector_contains(&process.tags, &tag)) {
                vector::push_back(&mut result, process.id);
            };
            i = i + 1;
        };
        
        result
    }
    
    /// Helper function to find process index in the vector
    fun find_process_index(processes: &vector<Process>, id: &String): u64 {
        let i = 0;
        let len = vector::length(processes);
        
        while (i < len) {
            let process = vector::borrow(processes, i);
            if (&process.id == id) {
                return i
            };
            i = i + 1;
        };
        
        len // Return length if not found (will be handled as not found)
    }
}

================
File: move/sources/queue.move
================
module a3::queue {
    use std::string::{String};
    use std::signer;
    use std::error;
    use std::vector;
    use aptos_framework::event;
    use aptos_framework::timestamp;
    use a3::process_registry;
    use a3::workflow;
    use a3::payment;
    
    /// Errors
    const E_NOT_AUTHORIZED: u64 = 1;
    const E_QUEUE_NOT_FOUND: u64 = 2;
    const E_QUEUE_ALREADY_EXISTS: u64 = 3;
    const E_TRANSACTION_NOT_FOUND: u64 = 4;
    const E_INVALID_TRANSACTION_STATUS: u64 = 5;
    const E_PAYMENT_REQUIRED: u64 = 6;
    const E_PROCESS_NOT_FOUND: u64 = 7;
    
    /// Transaction status
    const TRANSACTION_STATUS_PENDING: u8 = 0;
    const TRANSACTION_STATUS_PROCESSING: u8 = 1;
    const TRANSACTION_STATUS_COMPLETED: u8 = 2;
    const TRANSACTION_STATUS_FAILED: u8 = 3;
    const TRANSACTION_STATUS_CANCELED: u8 = 4;
    
    /// Transaction priority
    const PRIORITY_LOW: u8 = 0;
    const PRIORITY_NORMAL: u8 = 1;
    const PRIORITY_HIGH: u8 = 2;
    const PRIORITY_URGENT: u8 = 3;
    
    /// Transaction structure
    struct Transaction has key, store {
        id: String,
        process_id: String,
        workflow_id: Option<String>,
        task_id: Option<String>,
        sender: address,
        status: u8,
        priority: u8,
        data: vector<u8>, // Serialized transaction data
        created_at: u64,
        updated_at: u64,
    }
    
    /// Queue structure
    struct TransactionQueue has key {
        name: String,
        owner: address,
        transactions: vector<Transaction>,
        processing_limit: u64, // Max number of transactions to process simultaneously
        created_at: u64,
        updated_at: u64,
    }
    
    /// Events
    struct TransactionSubmittedEvent has drop, store {
        transaction_id: String,
        process_id: String,
        sender: address,
        priority: u8,
        timestamp: u64,
    }
    
    struct TransactionStatusChangedEvent has drop, store {
        transaction_id: String,
        process_id: String,
        old_status: u8,
        new_status: u8,
        timestamp: u64,
    }
    
    /// Initialize a new queue
    public entry fun initialize_queue(
        account: &signer,
        queue_name: String,
        processing_limit: u64
    ) {
        let account_addr = signer::address_of(account);
        
        // Check if queue already exists
        assert!(!exists<TransactionQueue>(account_addr), error::already_exists(E_QUEUE_ALREADY_EXISTS));
        
        let current_time = timestamp::now_seconds();
        
        // Create the queue
        let queue = TransactionQueue {
            name: queue_name,
            owner: account_addr,
            transactions: vector::empty<Transaction>(),
            processing_limit,
            created_at: current_time,
            updated_at: current_time,
        };
        
        // Store queue
        move_to(account, queue);
    }
    
    /// Submit a transaction to the queue
    public entry fun submit_transaction(
        account: &signer,
        process_id: String,
        transaction_id: String,
        workflow_id_option: Option<String>,
        task_id_option: Option<String>,
        priority: u8,
        data: vector<u8>
    ) {
        let sender_addr = signer::address_of(account);
        
        // Check process exists
        assert!(process_registry::process_exists(process_id), error::not_found(E_PROCESS_NOT_FOUND));
        
        // Get process details
        let (_, _, process_owner, _, _, _, _, pricing_option, _, _) = process_registry::get_process(process_id);
        
        // Check if payment is required and made
        if (option::is_some(&pricing_option)) {
            let pricing = option::borrow(&pricing_option);
            if (pricing.requires_prepayment) {
                assert!(payment::verify_payment(process_id, sender_addr), error::invalid_state(E_PAYMENT_REQUIRED));
            };
        };
        
        // Validate priority
        assert!(
            priority == PRIORITY_LOW ||
            priority == PRIORITY_NORMAL ||
            priority == PRIORITY_HIGH ||
            priority == PRIORITY_URGENT,
            error::invalid_argument(E_INVALID_TRANSACTION_STATUS)
        );
        
        // Create transaction
        let current_time = timestamp::now_seconds();
        let transaction = Transaction {
            id: transaction_id,
            process_id,
            workflow_id: workflow_id_option,
            task_id: task_id_option,
            sender: sender_addr,
            status: TRANSACTION_STATUS_PENDING,
            priority,
            data,
            created_at: current_time,
            updated_at: current_time,
        };
        
        // Add to queue
        assert!(exists<TransactionQueue>(process_owner), error::not_found(E_QUEUE_NOT_FOUND));
        
        let queue = borrow_global_mut<TransactionQueue>(process_owner);
        vector::push_back(&mut queue.transactions, transaction);
        queue.updated_at = current_time;
        
        // Emit event
        event::emit(TransactionSubmittedEvent {
            transaction_id,
            process_id,
            sender: sender_addr,
            priority,
            timestamp: current_time,
        });
    }
    
    /// Update transaction status
    public entry fun update_transaction_status(
        account: &signer,
        transaction_id: String,
        new_status: u8
    ) {
        let account_addr = signer::address_of(account);
        
        // Check if queue exists
        assert!(exists<TransactionQueue>(account_addr), error::not_found(E_QUEUE_NOT_FOUND));
        
        // Get queue
        let queue = borrow_global_mut<TransactionQueue>(account_addr);
        
        // Find transaction
        let transaction_idx = find_transaction_index(&queue.transactions, transaction_id);
        assert!(transaction_idx < vector::length(&queue.transactions), error::not_found(E_TRANSACTION_NOT_FOUND));
        
        let transaction = vector::borrow_mut(&mut queue.transactions, transaction_idx);
        
        // Validate status
        assert!(
            new_status == TRANSACTION_STATUS_PENDING ||
            new_status == TRANSACTION_STATUS_PROCESSING ||
            new_status == TRANSACTION_STATUS_COMPLETED ||
            new_status == TRANSACTION_STATUS_FAILED ||
            new_status == TRANSACTION_STATUS_CANCELED,
            error::invalid_argument(E_INVALID_TRANSACTION_STATUS)
        );
        
        // Save old status for event
        let old_status = transaction.status;
        
        // Update status and timestamp
        transaction.status = new_status;
        transaction.updated_at = timestamp::now_seconds();
        queue.updated_at = transaction.updated_at;
        
        // Update workflow task status if applicable
        if (new_status == TRANSACTION_STATUS_COMPLETED && 
            option::is_some(&transaction.workflow_id) && 
            option::is_some(&transaction.task_id)) {
            
            // This part would typically update the workflow task status
            // but we just emit the event for now since we'd need to call other modules
        };
        
        // Emit event
        event::emit(TransactionStatusChangedEvent {
            transaction_id: transaction.id,
            process_id: transaction.process_id,
            old_status,
            new_status,
            timestamp: transaction.updated_at,
        });
    }
    
    /// Cancel a transaction
    public entry fun cancel_transaction(
        account: &signer,
        transaction_id: String
    ) {
        let sender_addr = signer::address_of(account);
        
        // Find the queue that contains this transaction
        let (queue_owner, transaction_idx) = find_transaction_owner_and_index(transaction_id);
        
        // Get queue
        let queue = borrow_global_mut<TransactionQueue>(queue_owner);
        let transaction = vector::borrow_mut(&mut queue.transactions, transaction_idx);
        
        // Only sender or queue owner can cancel
        assert!(
            transaction.sender == sender_addr || queue.owner == sender_addr,
            error::permission_denied(E_NOT_AUTHORIZED)
        );
        
        // Only pending or processing transactions can be canceled
        assert!(
            transaction.status == TRANSACTION_STATUS_PENDING || 
            transaction.status == TRANSACTION_STATUS_PROCESSING,
            error::invalid_state(E_INVALID_TRANSACTION_STATUS)
        );
        
        // Save old status for event
        let old_status = transaction.status;
        
        // Update status and timestamp
        transaction.status = TRANSACTION_STATUS_CANCELED;
        transaction.updated_at = timestamp::now_seconds();
        queue.updated_at = transaction.updated_at;
        
        // Emit event
        event::emit(TransactionStatusChangedEvent {
            transaction_id: transaction.id,
            process_id: transaction.process_id,
            old_status,
            new_status: TRANSACTION_STATUS_CANCELED,
            timestamp: transaction.updated_at,
        });
    }
    
    /// Get next transaction to process
    public fun get_next_transaction(owner: address): (String, String, Option<String>, Option<String>, address, vector<u8>) {
        assert!(exists<TransactionQueue>(owner), error::not_found(E_QUEUE_NOT_FOUND));
        
        let queue = borrow_global<TransactionQueue>(owner);
        
        // Find highest priority pending transaction
        let best_idx = find_highest_priority_pending_transaction(&queue.transactions);
        assert!(best_idx < vector::length(&queue.transactions), error::not_found(E_TRANSACTION_NOT_FOUND));
        
        let transaction = vector::borrow(&queue.transactions, best_idx);
        
        (
            transaction.id,
            transaction.process_id,
            transaction.workflow_id,
            transaction.task_id,
            transaction.sender,
            transaction.data
        )
    }
    
    /// Get transaction count in queue
    public fun get_queue_size(owner: address): u64 {
        if (!exists<TransactionQueue>(owner)) {
            return 0
        };
        
        let queue = borrow_global<TransactionQueue>(owner);
        vector::length(&queue.transactions)
    }
    
    /// Get pending transaction count
    public fun get_pending_transaction_count(owner: address): u64 {
        if (!exists<TransactionQueue>(owner)) {
            return 0
        };
        
        let queue = borrow_global<TransactionQueue>(owner);
        let count = 0;
        let i = 0;
        let len = vector::length(&queue.transactions);
        
        while (i < len) {
            let transaction = vector::borrow(&queue.transactions, i);
            if (transaction.status == TRANSACTION_STATUS_PENDING) {
                count = count + 1;
            };
            i = i + 1;
        };
        
        count
    }
    
    /// Helper function to find transaction in any queue
    fun find_transaction_owner_and_index(transaction_id: String): (address, u64) {
        // This is simplified - in a real implementation we would need
        // a global registry of all queues or transactions to find it
        // For now, we just check the a3 module account
        
        assert!(exists<TransactionQueue>(@a3), error::not_found(E_QUEUE_NOT_FOUND));
        
        let queue = borrow_global<TransactionQueue>(@a3);
        let idx = find_transaction_index(&queue.transactions, transaction_id);
        
        assert!(idx < vector::length(&queue.transactions), error::not_found(E_TRANSACTION_NOT_FOUND));
        
        (@a3, idx)
    }
    
    /// Helper function to find transaction index in queue
    fun find_transaction_index(transactions: &vector<Transaction>, transaction_id: String): u64 {
        let i = 0;
        let len = vector::length(transactions);
        
        while (i < len) {
            let transaction = vector::borrow(transactions, i);
            if (transaction.id == transaction_id) {
                return i
            };
            i = i + 1;
        };
        
        len // Return length if not found
    }
    
    /// Helper function to find highest priority pending transaction
    fun find_highest_priority_pending_transaction(transactions: &vector<Transaction>): u64 {
        let i = 0;
        let len = vector::length(transactions);
        let best_idx = len; // Default to not found
        let best_priority = PRIORITY_LOW - 1; // Lower than the lowest
        
        while (i < len) {
            let transaction = vector::borrow(transactions, i);
            if (transaction.status == TRANSACTION_STATUS_PENDING && 
                transaction.priority > best_priority) {
                best_idx = i;
                best_priority = transaction.priority;
            };
            i = i + 1;
        };
        
        best_idx
    }
}

================
File: move/sources/types.move
================
module a3::types {
    use std::string::{String};
    use std::vector;
    
    /// Status of a process
    const STATUS_ACTIVE: u8 = 1;
    const STATUS_INACTIVE: u8 = 2;
    const STATUS_ERROR: u8 = 3;
    
    /// Errors
    const E_NOT_AUTHORIZED: u64 = 1;
    const E_PROCESS_NOT_FOUND: u64 = 2;
    const E_PROCESS_ALREADY_EXISTS: u64 = 3;
    const E_PROFILE_NOT_FOUND: u64 = 4;
    const E_INVALID_PAYMENT: u64 = 5;
    const E_PAYMENT_REQUIRED: u64 = 6;
    
    /// Basic agent metadata
    struct Agent has store, drop, copy {
        id: String,
        name: String,
        instructions: String,
        goal: String,
        role: String,
    }
    
    /// Workflow metadata
    struct Workflow has store, drop, copy {
        id: String,
        name: String,
        description: String,
    }
    
    /// Social media links for creator profiles
    struct SocialLinks has store, drop, copy {
        twitter: String,
        discord: String,
        telegram: String,
        website: String,
        // Additional fields can be added as needed
    }
    
    /// Process pricing information
    struct Pricing has store, drop, copy {
        task_price: u64,  // In smallest unit of currency (e.g., octas for APT)
        currency: String, // Token type
        payment_address: address,
        requires_prepayment: bool,
    }
    
    /// Function to create a simple agent
    public fun create_agent(
        id: String,
        name: String,
        instructions: String,
        goal: String,
        role: String
    ): Agent {
        Agent {
            id,
            name,
            instructions,
            goal,
            role,
        }
    }
    
    /// Function to create a simple workflow
    public fun create_workflow(
        id: String,
        name: String,
        description: String
    ): Workflow {
        Workflow {
            id,
            name,
            description,
        }
    }
    
    /// Function to create social links
    public fun create_social_links(
        twitter: String,
        discord: String,
        telegram: String,
        website: String
    ): SocialLinks {
        SocialLinks {
            twitter,
            discord,
            telegram,
            website,
        }
    }
    
    /// Function to create pricing information
    public fun create_pricing(
        task_price: u64,
        currency: String,
        payment_address: address,
        requires_prepayment: bool
    ): Pricing {
        Pricing {
            task_price,
            currency,
            payment_address,
            requires_prepayment,
        }
    }
    
    /// Helper function to check if a vector contains a string
    public fun vector_contains(v: &vector<String>, item: &String): bool {
        let len = vector::length(v);
        let i = 0;
        while (i < len) {
            if (vector::borrow(v, i) == item) {
                return true
            };
            i = i + 1;
        };
        false
    }
}

================
File: move/sources/workflow.move
================
module a3::workflow {
    use std::string::{String};
    use std::signer;
    use std::error;
    use std::vector;
    use aptos_framework::event;
    use aptos_framework::timestamp;
    use a3::payment;

    /// Errors
    const E_NOT_AUTHORIZED: u64 = 1;
    const E_WORKFLOW_NOT_FOUND: u64 = 2;
    const E_WORKFLOW_ALREADY_EXISTS: u64 = 3;
    const E_TASK_NOT_FOUND: u64 = 4;
    const E_TASK_ALREADY_EXISTS: u64 = 5;
    const E_INVALID_WORKFLOW_STATUS: u64 = 6;
    const E_INVALID_TASK_STATUS: u64 = 7;
    const E_NO_PAYMENT_FOUND: u64 = 8;
    
    /// Workflow status
    const WORKFLOW_STATUS_DRAFT: u8 = 0;
    const WORKFLOW_STATUS_ACTIVE: u8 = 1;
    const WORKFLOW_STATUS_PAUSED: u8 = 2;
    const WORKFLOW_STATUS_COMPLETED: u8 = 3;
    const WORKFLOW_STATUS_ARCHIVED: u8 = 4;
    
    /// Task status
    const TASK_STATUS_PENDING: u8 = 0;
    const TASK_STATUS_IN_PROGRESS: u8 = 1;
    const TASK_STATUS_COMPLETED: u8 = 2;
    const TASK_STATUS_APPROVED: u8 = 3;
    const TASK_STATUS_FAILED: u8 = 4;
    
    /// Task structure
    struct Task has key, store, drop {
        id: String,
        name: String,
        description: String,
        owner: address,
        assignee: address,
        requester: address, // The user who requested the task
        process_id: String, // Associated process ID
        status: u8,
        dependencies: vector<String>, // Task IDs this task depends on
        created_at: u64,
        updated_at: u64,
    }
    
    /// Workflow structure
    struct Workflow has key, store {
        id: String,
        name: String,
        description: String,
        owner: address,
        status: u8,
        tasks: vector<Task>,
        created_at: u64,
        updated_at: u64,
    }
    
    /// Store for workflows
    struct WorkflowStore has key {
        workflows: vector<Workflow>,
    }
    
    /// Events
    struct WorkflowCreatedEvent has drop, store {
        id: String,
        name: String,
        owner: address,
        timestamp: u64,
    }
    
    struct WorkflowUpdatedEvent has drop, store {
        id: String,
        name: String,
        owner: address,
        status: u8,
        timestamp: u64,
    }
    
    struct TaskAddedEvent has drop, store {
        workflow_id: String,
        task_id: String,
        name: String,
        assignee: address,
        requester: address,
        process_id: String,
        timestamp: u64,
    }
    
    struct TaskUpdatedEvent has drop, store {
        workflow_id: String,
        task_id: String,
        status: u8,
        timestamp: u64,
    }
    
    struct TaskApprovedEvent has drop, store {
        workflow_id: String,
        task_id: String,
        requester: address,
        assignee: address,
        process_id: String,
        timestamp: u64,
    }
    
    struct PaymentReleasedEvent has drop, store {
        workflow_id: String,
        task_id: String,
        process_id: String,
        requester: address,
        assignee: address,
        amount: u64,
        timestamp: u64,
    }
    
    /// Initialize module
    public entry fun initialize(account: &signer) {
        let account_addr = signer::address_of(account);
        if (!exists<WorkflowStore>(account_addr)) {
            move_to(account, WorkflowStore {
                workflows: vector::empty<Workflow>(),
            });
        };
    }
    
    /// Create a new workflow
    public entry fun create_workflow(
        account: &signer,
        id: String,
        name: String,
        description: String
    ) {
        let owner = signer::address_of(account);
        
        // Check if workflow already exists
        assert!(!workflow_exists(id), error::already_exists(E_WORKFLOW_ALREADY_EXISTS));
        
        let current_time = timestamp::now_seconds();
        
        // Create new workflow
        let workflow = Workflow {
            id,
            name,
            description,
            owner,
            status: WORKFLOW_STATUS_DRAFT,
            tasks: vector::empty<Task>(),
            created_at: current_time,
            updated_at: current_time,
        };
        
        // Store workflow
        if (!exists<WorkflowStore>(@a3)) {
            move_to(account, WorkflowStore {
                workflows: vector::singleton(workflow),
            });
        } else {
            let store = borrow_global_mut<WorkflowStore>(@a3);
            vector::push_back(&mut store.workflows, workflow);
        };
        
        // Emit event
        event::emit(WorkflowCreatedEvent {
            id,
            name,
            owner,
            timestamp: current_time,
        });
    }
    
    /// Update workflow status
    public entry fun update_workflow_status(
        account: &signer,
        workflow_id: String,
        new_status: u8
    ) {
        let account_addr = signer::address_of(account);
        
        // Check workflow exists
        assert!(workflow_exists(workflow_id), error::not_found(E_WORKFLOW_NOT_FOUND));
        
        // Get workflow
        let store = borrow_global_mut<WorkflowStore>(@a3);
        let workflow_idx = find_workflow_index(&store.workflows, workflow_id);
        let workflow = vector::borrow_mut(&mut store.workflows, workflow_idx);
        
        // Check authorization
        assert!(workflow.owner == account_addr, error::permission_denied(E_NOT_AUTHORIZED));
        
        // Check valid status
        assert!(
            new_status == WORKFLOW_STATUS_DRAFT ||
            new_status == WORKFLOW_STATUS_ACTIVE ||
            new_status == WORKFLOW_STATUS_PAUSED ||
            new_status == WORKFLOW_STATUS_COMPLETED ||
            new_status == WORKFLOW_STATUS_ARCHIVED,
            error::invalid_argument(E_INVALID_WORKFLOW_STATUS)
        );
        
        // Update status
        workflow.status = new_status;
        workflow.updated_at = timestamp::now_seconds();
        
        // Emit event
        event::emit(WorkflowUpdatedEvent {
            id: workflow.id,
            name: workflow.name,
            owner: workflow.owner,
            status: new_status,
            timestamp: workflow.updated_at,
        });
    }
    
    /// Add task to workflow
    public entry fun add_task(
        account: &signer,
        workflow_id: String,
        task_id: String,
        task_name: String,
        task_description: String,
        assignee: address,
        requester: address,
        process_id: String,
        dependencies: vector<String>
    ) {
        let account_addr = signer::address_of(account);
        
        // Check workflow exists
        assert!(workflow_exists(workflow_id), error::not_found(E_WORKFLOW_NOT_FOUND));
        
        // Get workflow
        let store = borrow_global_mut<WorkflowStore>(@a3);
        let workflow_idx = find_workflow_index(&store.workflows, workflow_id);
        let workflow = vector::borrow_mut(&mut store.workflows, workflow_idx);
        
        // Check authorization
        assert!(workflow.owner == account_addr, error::permission_denied(E_NOT_AUTHORIZED));
        
        // Check if task already exists
        assert!(!task_exists_in_workflow(workflow, task_id), error::already_exists(E_TASK_ALREADY_EXISTS));
        
        // Create task
        let current_time = timestamp::now_seconds();
        let task = Task {
            id: task_id,
            name: task_name,
            description: task_description,
            owner: account_addr,
            assignee,
            requester,
            process_id,
            status: TASK_STATUS_PENDING,
            dependencies,
            created_at: current_time,
            updated_at: current_time,
        };
        
        // Add task to workflow
        vector::push_back(&mut workflow.tasks, task);
        workflow.updated_at = current_time;
        
        // Emit event
        event::emit(TaskAddedEvent {
            workflow_id: workflow_id,
            task_id,
            name: task_name,
            assignee,
            requester,
            process_id,
            timestamp: current_time,
        });
    }
    
    /// Update task status
    public entry fun update_task_status(
        account: &signer,
        workflow_id: String,
        task_id: String,
        new_status: u8
    ) {
        let account_addr = signer::address_of(account);
        
        // Check workflow exists
        assert!(workflow_exists(workflow_id), error::not_found(E_WORKFLOW_NOT_FOUND));
        
        // Get workflow
        let store = borrow_global_mut<WorkflowStore>(@a3);
        let workflow_idx = find_workflow_index(&store.workflows, workflow_id);
        let workflow = vector::borrow_mut(&mut store.workflows, workflow_idx);
        
        // Find task
        let task_idx = find_task_index_in_workflow(workflow, task_id);
        assert!(task_idx < vector::length(&workflow.tasks), error::not_found(E_TASK_NOT_FOUND));
        
        let task = vector::borrow_mut(&mut workflow.tasks, task_idx);
        
        // Check authorization (owner or assignee)
        assert!(
            workflow.owner == account_addr || task.assignee == account_addr,
            error::permission_denied(E_NOT_AUTHORIZED)
        );
        
        // Only allow certain status transitions
        if (account_addr == task.assignee) {
            // Assignee can only mark as COMPLETED or FAILED
            assert!(
                new_status == TASK_STATUS_IN_PROGRESS || 
                new_status == TASK_STATUS_COMPLETED || 
                new_status == TASK_STATUS_FAILED,
                error::invalid_argument(E_INVALID_TASK_STATUS)
            );
        } else {
            // Owner can change to any status
            assert!(
                new_status == TASK_STATUS_PENDING ||
                new_status == TASK_STATUS_IN_PROGRESS ||
                new_status == TASK_STATUS_COMPLETED ||
                new_status == TASK_STATUS_APPROVED ||
                new_status == TASK_STATUS_FAILED,
                error::invalid_argument(E_INVALID_TASK_STATUS)
            );
        };
        
        // Update status
        task.status = new_status;
        task.updated_at = timestamp::now_seconds();
        workflow.updated_at = task.updated_at;
        
        // Emit event
        event::emit(TaskUpdatedEvent {
            workflow_id: workflow_id,
            task_id: task_id,
            status: new_status,
            timestamp: task.updated_at,
        });
        
        // Check if all tasks are completed or approved
        let all_completed = true;
        let i = 0;
        let len = vector::length(&workflow.tasks);
        
        while (i < len) {
            let task = vector::borrow(&workflow.tasks, i);
            if (task.status != TASK_STATUS_COMPLETED && task.status != TASK_STATUS_APPROVED) {
                all_completed = false;
                break
            };
            i = i + 1;
        };
        
        // If all tasks completed, update workflow status
        if (all_completed && workflow.status == WORKFLOW_STATUS_ACTIVE) {
            workflow.status = WORKFLOW_STATUS_COMPLETED;
            
            // Emit workflow updated event
            event::emit(WorkflowUpdatedEvent {
                id: workflow.id,
                name: workflow.name,
                owner: workflow.owner,
                status: WORKFLOW_STATUS_COMPLETED,
                timestamp: workflow.updated_at,
            });
        };
    }
    
    /// Approve a completed task and release payment
    public entry fun approve_task_and_release_payment(
        account: &signer,
        workflow_id: String,
        task_id: String
    ) {
        let requester_addr = signer::address_of(account);
        
        // Check workflow exists
        assert!(workflow_exists(workflow_id), error::not_found(E_WORKFLOW_NOT_FOUND));
        
        // Get workflow
        let store = borrow_global_mut<WorkflowStore>(@a3);
        let workflow_idx = find_workflow_index(&store.workflows, workflow_id);
        let workflow = vector::borrow_mut(&mut store.workflows, workflow_idx);
        
        // Find task
        let task_idx = find_task_index_in_workflow(workflow, task_id);
        assert!(task_idx < vector::length(&workflow.tasks), error::not_found(E_TASK_NOT_FOUND));
        
        let task = vector::borrow_mut(&mut workflow.tasks, task_idx);
        
        // Check authorization (only requester can approve)
        assert!(task.requester == requester_addr, error::permission_denied(E_NOT_AUTHORIZED));
        
        // Check task is completed
        assert!(task.status == TASK_STATUS_COMPLETED, error::invalid_state(E_INVALID_TASK_STATUS));
        
        // Check if payment exists
        assert!(payment::payment_exists(task.process_id, task.id, requester_addr), error::not_found(E_NO_PAYMENT_FOUND));
        
        // Update task status to approved
        task.status = TASK_STATUS_APPROVED;
        task.updated_at = timestamp::now_seconds();
        workflow.updated_at = task.updated_at;
        
        // Release payment
        payment::release_payment(account, task.process_id, task.id);
        
        // Get payment details for the event
        let (_, _, _, _, amount, _, _, _, _) = payment::get_payment(task.process_id, task.id, requester_addr);
        
        // Emit task approved event
        event::emit(TaskApprovedEvent {
            workflow_id: workflow_id,
            task_id: task_id,
            requester: requester_addr,
            assignee: task.assignee,
            process_id: task.process_id,
            timestamp: task.updated_at,
        });
        
        // Emit payment released event
        event::emit(PaymentReleasedEvent {
            workflow_id: workflow_id,
            task_id: task_id,
            process_id: task.process_id,
            requester: requester_addr,
            assignee: task.assignee,
            amount: amount,
            timestamp: task.updated_at,
        });
    }
    
    /// Check if workflow exists
    public fun workflow_exists(workflow_id: String): bool {
        if (!exists<WorkflowStore>(@a3)) {
            return false
        };
        
        let store = borrow_global<WorkflowStore>(@a3);
        find_workflow_index(&store.workflows, workflow_id) < vector::length(&store.workflows)
    }
    
    /// Get workflow details
    public fun get_workflow(workflow_id: String): (
        String, String, String, address, u8, u64, u64
    ) {
        assert!(workflow_exists(workflow_id), error::not_found(E_WORKFLOW_NOT_FOUND));
        
        let store = borrow_global<WorkflowStore>(@a3);
        let workflow_idx = find_workflow_index(&store.workflows, workflow_id);
        let workflow = vector::borrow(&store.workflows, workflow_idx);
        
        (
            workflow.id,
            workflow.name,
            workflow.description,
            workflow.owner,
            workflow.status,
            workflow.created_at,
            workflow.updated_at
        )
    }
    
    /// Get workflow task count
    public fun get_workflow_task_count(workflow_id: String): u64 {
        assert!(workflow_exists(workflow_id), error::not_found(E_WORKFLOW_NOT_FOUND));
        
        let store = borrow_global<WorkflowStore>(@a3);
        let workflow_idx = find_workflow_index(&store.workflows, workflow_id);
        let workflow = vector::borrow(&store.workflows, workflow_idx);
        
        vector::length(&workflow.tasks)
    }
    
    /// Get task details by index
    public fun get_task_by_index(workflow_id: String, task_idx: u64): (
        String, String, String, address, address, address, String, u8, u64, u64
    ) {
        assert!(workflow_exists(workflow_id), error::not_found(E_WORKFLOW_NOT_FOUND));
        
        let store = borrow_global<WorkflowStore>(@a3);
        let workflow_idx = find_workflow_index(&store.workflows, workflow_id);
        let workflow = vector::borrow(&store.workflows, workflow_idx);
        
        assert!(task_idx < vector::length(&workflow.tasks), error::invalid_argument(E_TASK_NOT_FOUND));
        
        let task = vector::borrow(&workflow.tasks, task_idx);
        
        (
            task.id,
            task.name,
            task.description,
            task.owner,
            task.assignee,
            task.requester,
            task.process_id,
            task.status,
            task.created_at,
            task.updated_at
        )
    }
    
    /// Helper function to find workflow index
    fun find_workflow_index(workflows: &vector<Workflow>, workflow_id: String): u64 {
        let i = 0;
        let len = vector::length(workflows);
        
        while (i < len) {
            let workflow = vector::borrow(workflows, i);
            if (workflow.id == workflow_id) {
                return i
            };
            i = i + 1;
        };
        
        len // Return length if not found
    }
    
    /// Helper function to check if task exists in workflow
    fun task_exists_in_workflow(workflow: &Workflow, task_id: String): bool {
        find_task_index_in_workflow(workflow, task_id) < vector::length(&workflow.tasks)
    }
    
    /// Helper function to find task index in workflow
    fun find_task_index_in_workflow(workflow: &Workflow, task_id: String): u64 {
        let i = 0;
        let len = vector::length(&workflow.tasks);
        
        while (i < len) {
            let task = vector::borrow(&workflow.tasks, i);
            if (task.id == task_id) {
                return i
            };
            i = i + 1;
        };
        
        len // Return length if not found
    }
}

================
File: move/tests/a3_test.move
================
#[test_only]
module a3::a3_test {
    use std::string::{String};
    use std::signer;
    use std::vector;
    use aptos_framework::timestamp;
    use aptos_framework::account;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    use a3::a3_manager;
    use a3::creator_profile;
    use a3::process_registry;
    use a3::payment;
    use a3::workflow;
    use a3::queue;
    
    /// Test account addresses
    const ADMIN_ADDR: address = @0xA1;
    const CREATOR_ADDR: address = @0xA2;
    const USER_ADDR: address = @0xA3;
    
    /// Initialize test environment
    fun setup_test(
        aptos_framework: &signer,
        a3: &signer,
        admin: &signer,
        creator: &signer,
        user: &signer
    ) {
        // Initialize the Aptos framework for testing
        timestamp::set_time_has_started_for_testing(aptos_framework);
        
        // Create test accounts
        account::create_account_for_test(signer::address_of(admin));
        account::create_account_for_test(signer::address_of(creator));
        account::create_account_for_test(signer::address_of(user));
        account::create_account_for_test(signer::address_of(a3));
        
        // Initialize A3 system
        a3_manager::initialize(a3, 100, signer::address_of(admin)); // 1% fee
    }
    
    #[test(aptos_framework = @aptos_framework, a3 = @a3, admin = @0xA1, creator = @0xA2, user = @0xA3)]
    public entry fun test_creator_profile(
        aptos_framework: &signer,
        a3: &signer,
        admin: &signer,
        creator: &signer,
        user: &signer
    ) {
        setup_test(aptos_framework, a3, admin, creator, user);
        
        // Create a creator profile
        creator_profile::create_profile(
            creator,
            String::utf8(b"Test Creator"),
            String::utf8(b"A test creator for the A3 system"),
            signer::address_of(creator),
            vector::empty<String>()
        );
        
        // Verify profile exists
        assert!(creator_profile::profile_exists(signer::address_of(creator)), 0);
        
        // Get profile details and verify
        let (name, description, wallet, _, _) = creator_profile::get_profile(signer::address_of(creator));
        assert!(name == String::utf8(b"Test Creator"), 1);
        assert!(description == String::utf8(b"A test creator for the A3 system"), 2);
        assert!(wallet == signer::address_of(creator), 3);
    }
    
    #[test(aptos_framework = @aptos_framework, a3 = @a3, admin = @0xA1, creator = @0xA2, user = @0xA3)]
    public entry fun test_process_registry(
        aptos_framework: &signer,
        a3: &signer,
        admin: &signer,
        creator: &signer,
        user: &signer
    ) {
        setup_test(aptos_framework, a3, admin, creator, user);
        
        // Register a process
        let process_id = String::utf8(b"process_1");
        process_registry::register_process(
            creator,
            process_id,
            String::utf8(b"Test Process"),
            String::utf8(b"A test process for the A3 system"),
            vector::empty<address>(), // No agents
            vector::empty<String>(), // No workflows
            vector[String::utf8(b"test"), String::utf8(b"demo")] // Tags
        );
        
        // Verify process exists
        assert!(process_registry::process_exists(process_id), 0);
        
        // Get process details and verify
        let (id, name, owner, _, _, _, tags, _, _, _) = process_registry::get_process(process_id);
        assert!(id == process_id, 1);
        assert!(name == String::utf8(b"Test Process"), 2);
        assert!(owner == signer::address_of(creator), 3);
        assert!(vector::length(&tags) == 2, 4);
        assert!(*vector::borrow(&tags, 0) == String::utf8(b"test"), 5);
        assert!(*vector::borrow(&tags, 1) == String::utf8(b"demo"), 6);
    }
    
    #[test(aptos_framework = @aptos_framework, a3 = @a3, admin = @0xA1, creator = @0xA2, user = @0xA3)]
    public entry fun test_workflow(
        aptos_framework: &signer,
        a3: &signer,
        admin: &signer,
        creator: &signer,
        user: &signer
    ) {
        setup_test(aptos_framework, a3, admin, creator, user);
        
        // Create a workflow
        let workflow_id = String::utf8(b"workflow_1");
        workflow::create_workflow(
            creator,
            workflow_id,
            String::utf8(b"Test Workflow"),
            String::utf8(b"A test workflow")
        );
        
        // Verify workflow exists
        assert!(workflow::workflow_exists(workflow_id), 0);
        
        // Get workflow details and verify
        let (id, name, description, owner, status, _, _) = workflow::get_workflow(workflow_id);
        assert!(id == workflow_id, 1);
        assert!(name == String::utf8(b"Test Workflow"), 2);
        assert!(description == String::utf8(b"A test workflow"), 3);
        assert!(owner == signer::address_of(creator), 4);
        assert!(status == 0, 5); // Draft status
        
        // Add a task
        workflow::add_task(
            creator,
            workflow_id,
            String::utf8(b"task_1"),
            String::utf8(b"Test Task"),
            String::utf8(b"A test task"),
            signer::address_of(user), // Assignee
            vector::empty<String>() // No dependencies
        );
        
        // Verify task count
        assert!(workflow::get_workflow_task_count(workflow_id) == 1, 6);
    }
    
    #[test(aptos_framework = @aptos_framework, a3 = @a3, admin = @0xA1, creator = @0xA2, user = @0xA3)]
    #[expected_failure(abort_code = 5)] // E_PAYMENT_NOT_REQUIRED
    public entry fun test_payment_failure(
        aptos_framework: &signer,
        a3: &signer,
        admin: &signer,
        creator: &signer,
        user: &signer
    ) {
        setup_test(aptos_framework, a3, admin, creator, user);
        
        // Register a process without pricing
        let process_id = String::utf8(b"process_1");
        process_registry::register_process(
            creator,
            process_id,
            String::utf8(b"Test Process"),
            String::utf8(b"A test process for the A3 system"),
            vector::empty<address>(), // No agents
            vector::empty<String>(), // No workflows
            vector[String::utf8(b"test")] // Tags
        );
        
        // Try to make payment for a process that doesn't require payment
        // This should fail with E_PAYMENT_NOT_REQUIRED
        payment::make_payment(
            user,
            process_id,
            1000000 // 1 APT
        );
    }
    
    #[test(aptos_framework = @aptos_framework, a3 = @a3, admin = @0xA1, creator = @0xA2, user = @0xA3)]
    public entry fun test_queue(
        aptos_framework: &signer,
        a3: &signer,
        admin: &signer,
        creator: &signer,
        user: &signer
    ) {
        setup_test(aptos_framework, a3, admin, creator, user);
        
        // Initialize a queue
        queue::initialize_queue(
            creator,
            String::utf8(b"Test Queue"),
            5 // Processing limit
        );
        
        // Register a process
        let process_id = String::utf8(b"process_1");
        process_registry::register_process(
            creator,
            process_id,
            String::utf8(b"Test Process"),
            String::utf8(b"A test process for the A3 system"),
            vector::empty<address>(), // No agents
            vector::empty<String>(), // No workflows
            vector[String::utf8(b"test")] // Tags
        );
        
        // Submit a transaction
        queue::submit_transaction(
            user,
            process_id,
            String::utf8(b"tx_1"),
            option::none<String>(), // No workflow
            option::none<String>(), // No task
            1, // Normal priority
            vector[0, 1, 2, 3] // Sample data
        );
        
        // Verify queue size
        assert!(queue::get_queue_size(signer::address_of(creator)) == 1, 0);
        
        // Verify pending transaction count
        assert!(queue::get_pending_transaction_count(signer::address_of(creator)) == 1, 1);
    }
    
    #[test(aptos_framework = @aptos_framework, a3 = @a3, admin = @0xA1, creator = @0xA2, user = @0xA3)]
    public entry fun test_a3_manager(
        aptos_framework: &signer,
        a3: &signer,
        admin: &signer,
        creator: &signer,
        user: &signer
    ) {
        setup_test(aptos_framework, a3, admin, creator, user);
        
        // Get protocol fee info
        let (fee_percentage, fee_recipient) = a3_manager::get_protocol_fee_info();
        assert!(fee_percentage == 100, 0); // 1%
        assert!(fee_recipient == signer::address_of(admin), 1);
        
        // Update protocol fee
        a3_manager::update_protocol_fee(
            a3, // Only admin can update
            200, // 2%
            signer::address_of(creator) // New recipient
        );
        
        // Verify updated fee info
        let (fee_percentage, fee_recipient) = a3_manager::get_protocol_fee_info();
        assert!(fee_percentage == 200, 2); // 2%
        assert!(fee_recipient == signer::address_of(creator), 3);
        
        // Register creator and process in one step
        a3_manager::register_creator_and_process(
            user,
            String::utf8(b"Test User"),
            String::utf8(b"A test user"),
            vector::empty<String>(), // No social links
            String::utf8(b"user_process"),
            String::utf8(b"User Process"),
            String::utf8(b"A process created by user"),
            vector[String::utf8(b"user"), String::utf8(b"test")]
        );
        
        // Verify creator profile exists
        assert!(creator_profile::profile_exists(signer::address_of(user)), 4);
        
        // Verify process exists
        assert!(process_registry::process_exists(String::utf8(b"user_process")), 5);
    }
}

================
File: move/Move.toml
================
[package]
name = "a3"
version = "0.1.0"
authors = ["A3 Team"]

[addresses]
a3 = "_" # This will be replaced during deployment with the actual address

[dependencies]
AptosFramework = { git = "https://github.com/aptos-labs/aptos-core.git", subdir = "aptos-move/framework/aptos-framework/", rev = "main" }

================
File: src/agent/agent-service.ts
================
import cors from 'cors';
import dotenv from 'dotenv';
import express from 'express';
import { v4 as uuidv4 } from 'uuid';

// Load environment variables
dotenv.config();

/**
 * Agent service configuration
 */
export interface AgentServiceConfig {
  port: number;
  processId: string;
  processName: string;
  workflowHandlers: Record<string, WorkflowHandler>;
  onRequest?: (request: AgentRequest) => Promise<void>;
  onRequestComplete?: (request: AgentRequest, response: AgentResponse) => Promise<void>;
}

/**
 * Agent request interface
 */
export interface AgentRequest {
  transactionId: string;
  processId: string;
  userAddress: string;
  data: Record<string, any>;
  workflowId?: string;
  taskId?: string;
  priority?: number;
}

/**
 * Agent response interface
 */
export interface AgentResponse {
  success: boolean;
  result?: any;
  error?: string;
  executionTime?: number;
  logs?: string[];
}

/**
 * Workflow handler type
 */
export type WorkflowHandler = (request: AgentRequest) => Promise<AgentResponse>;

/**
 * Agent Service
 * 
 * This service handles incoming requests for agent processes:
 * 1. Receives requests from the gateway
 * 2. Routes them to the appropriate workflow handler
 * 3. Returns the results to the gateway
 */
export class AgentService {
  private app: express.Application;
  private port: number;
  private processId: string;
  private processName: string;
  private workflowHandlers: Record<string, WorkflowHandler>;
  private onRequest?: (request: AgentRequest) => Promise<void>;
  private onRequestComplete?: (request: AgentRequest, response: AgentResponse) => Promise<void>;
  private logs: Map<string, string[]> = new Map();
  
  constructor(config: AgentServiceConfig) {
    this.port = config.port;
    this.processId = config.processId;
    this.processName = config.processName;
    this.workflowHandlers = config.workflowHandlers;
    this.onRequest = config.onRequest;
    this.onRequestComplete = config.onRequestComplete;
    
    // Initialize Express app
    this.app = express();
    this.app.use(express.json());
    this.app.use(cors());
    
    // Set up routes
    this.setupRoutes();
  }
  
  /**
   * Set up API routes
   */
  private setupRoutes(): void {
    // Health check
    this.app.get('/health', (req, res) => {
      res.status(200).json({
        status: 'ok',
        process: {
          id: this.processId,
          name: this.processName
        },
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        timestamp: new Date().toISOString()
      });
    });
    
    // Process info
    this.app.get('/info', (req, res) => {
      const workflowIds = Object.keys(this.workflowHandlers);
      
      res.status(200).json({
        process: {
          id: this.processId,
          name: this.processName
        },
        workflows: workflowIds,
        uptime: process.uptime(),
        timestamp: new Date().toISOString()
      });
    });
    
    // Execute process
    this.app.post('/execute', async (req, res) => {
      try {
        const request: AgentRequest = req.body;
        
        // Validate request
        if (!request.transactionId || !request.processId || !request.userAddress) {
          return res.status(400).json({
            success: false,
            error: 'Invalid request: missing required fields'
          });
        }
        
        // Validate process ID
        if (request.processId !== this.processId) {
          return res.status(400).json({
            success: false,
            error: `Incorrect process ID: expected ${this.processId}, got ${request.processId}`
          });
        }
        
        // Initialize logs for this request
        this.logs.set(request.transactionId, []);
        
        // Call onRequest callback if provided
        if (this.onRequest) {
          await this.onRequest(request);
        }
        
        // Log request receipt
        this.log(request.transactionId, `Received request: ${JSON.stringify(request)}`);
        
        // Start timing execution
        const startTime = Date.now();
        
        // Determine which workflow handler to use
        let handler: WorkflowHandler;
        
        if (request.workflowId && this.workflowHandlers[request.workflowId]) {
          handler = this.workflowHandlers[request.workflowId];
          this.log(request.transactionId, `Using handler for workflow: ${request.workflowId}`);
        } else if (this.workflowHandlers['default']) {
          handler = this.workflowHandlers['default'];
          this.log(request.transactionId, `Using default workflow handler`);
        } else {
          this.log(request.transactionId, `No handler found for workflow: ${request.workflowId}`);
          return res.status(400).json({
            success: false,
            error: `No handler available for workflow: ${request.workflowId || 'undefined'}`
          });
        }
        
        // Process the request
        let response: AgentResponse;
        try {
          response = await handler(request);
          response.executionTime = Date.now() - startTime;
          response.logs = this.logs.get(request.transactionId) || [];
          
          this.log(request.transactionId, `Request processed successfully`);
        } catch (error) {
          this.log(request.transactionId, `Error processing request: ${error instanceof Error ? error.message : 'Unknown error'}`);
          
          response = {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error during processing',
            executionTime: Date.now() - startTime,
            logs: this.logs.get(request.transactionId) || []
          };
        }
        
        // Call onRequestComplete callback if provided
        if (this.onRequestComplete) {
          await this.onRequestComplete(request, response);
        }
        
        // Clean up logs
        this.logs.delete(request.transactionId);
        
        // Return response
        res.status(response.success ? 200 : 400).json(response);
      } catch (error) {
        console.error('Error in request handler:', error);
        res.status(500).json({
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error in request handling'
        });
      }
    });
    
    // Transaction logs endpoint
    this.app.get('/logs/:transactionId', (req, res) => {
      const { transactionId } = req.params;
      const logs = this.logs.get(transactionId) || [];
      
      res.status(200).json({
        transactionId,
        logs,
        timestamp: new Date().toISOString()
      });
    });
  }
  
  /**
   * Start the service
   */
  public start(): void {
    this.app.listen(this.port, () => {
      console.log(`🚀 Agent Service running on port ${this.port}`);
      console.log(`📦 Process: ${this.processName} (${this.processId})`);
      console.log(`🧩 Available workflows: ${Object.keys(this.workflowHandlers).join(', ')}`);
    });
  }
  
  /**
   * Add a log entry for a transaction
   */
  private log(transactionId: string, message: string): void {
    const logs = this.logs.get(transactionId) || [];
    logs.push(`[${new Date().toISOString()}] ${message}`);
    this.logs.set(transactionId, logs);
  }
  
  /**
   * Create a default agent service
   */
  public static createDefaultService(config: {
    port: number;
    processId: string;
    processName: string;
    handler: (request: AgentRequest) => Promise<any>;
  }): AgentService {
    // Create a default workflow handler
    const defaultHandler: WorkflowHandler = async (request: AgentRequest): Promise<AgentResponse> => {
      try {
        const result = await config.handler(request);
        return {
          success: true,
          result
        };
      } catch (error) {
        return {
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error'
        };
      }
    };
    
    // Create and return the service
    return new AgentService({
      port: config.port,
      processId: config.processId,
      processName: config.processName,
      workflowHandlers: {
        default: defaultHandler
      }
    });
  }
}

/**
 * Create and start a default agent service
 */
if (require.main === module) {
  // This code only runs if the file is executed directly
  const port = parseInt(process.env.PORT || '3001');
  const processId = process.env.PROCESS_ID || uuidv4();
  const processName = process.env.PROCESS_NAME || 'Default Agent Process';
  
  // Create a simple echo handler
  const echoHandler = async (request: AgentRequest): Promise<any> => {
    return {
      message: 'Echo response',
      receivedData: request.data,
      timestamp: new Date().toISOString()
    };
  };
  
  // Create and start the service
  const service = AgentService.createDefaultService({
    port,
    processId,
    processName,
    handler: echoHandler
  });
  
  service.start();
}

================
File: src/api/agent-gateway.ts
================
import { AptosClient } from 'aptos';
import cors from 'cors';
import dotenv from 'dotenv';
import express from 'express';

import { AptosDiscoveryService } from '../discovery/aptos-discovery-service';
import { AptosPaymentService } from '../payment/payment-service';
import { TransactionHandler } from '../transaction/transaction-handler';

// Load environment variables
dotenv.config();

/**
 * Gateway server configuration
 */
export interface GatewayConfig {
  port: number;
  moduleAddress: string;
  aptosNetwork: string;
  privateKey: string;
}

/**
 * Agent Gateway Server
 * 
 * This server acts as a gateway for agent process requests:
 * 1. Validates payment for process execution
 * 2. Records transactions on the blockchain
 * 3. Forwards requests to the appropriate agent process
 * 4. Updates transaction status on the blockchain
 */
export class AgentGatewayServer {
  private app: express.Application;
  private port: number;
  private moduleAddress: string;
  private aptosClient: AptosClient;
  private transactionHandler: TransactionHandler;
  
  constructor(config: GatewayConfig) {
    this.port = config.port;
    this.moduleAddress = config.moduleAddress;
    
    // Initialize Express app
    this.app = express();
    this.app.use(express.json());
    this.app.use(cors());
    
    // Initialize Aptos client
    const networkUrl = this.getNetworkUrl(config.aptosNetwork);
    this.aptosClient = new AptosClient(networkUrl);
    
    // Initialize services
    const paymentService = new AptosPaymentService({
      moduleAddress: config.moduleAddress,
      aptosClient: this.aptosClient
    });
    
    const discoveryService = new AptosDiscoveryService({
      moduleAddress: config.moduleAddress,
      aptosClient: this.aptosClient
    });
    
    // Initialize transaction handler
    this.transactionHandler = new TransactionHandler({
      moduleAddress: config.moduleAddress,
      aptosClient: this.aptosClient,
      paymentService,
      discoveryService
    });
    
    // Set up routes
    this.setupRoutes();
  }
  
  /**
   * Set up API routes
   */
  private setupRoutes(): void {
    // Health check
    this.app.get('/health', (req, res) => {
      res.status(200).json({
        status: 'ok',
        timestamp: new Date().toISOString()
      });
    });
    
    // Process execution endpoint
    this.app.post('/api/execute/:processId', async (req, res) => {
      try {
        const { processId } = req.params;
        const { userAddress, data, workflowId, taskId, priority } = req.body;
        
        if (!userAddress) {
          return res.status(400).json({
            success: false,
            error: 'User address is required'
          });
        }
        
        // Get account from the private key (for demo purposes)
        // In production, this would be managed differently for security
        const account = this.getAccountFromPrivateKey();
        
        // Process the transaction
        const result = await this.transactionHandler.handleTransaction({
          processId,
          userAddress,
          data: data || {},
          workflowId,
          taskId,
          priority: priority || 1
        }, account);
        
        // Return response
        res.status(result.status === 'failed' ? 400 : 200).json({
          success: result.status === 'completed',
          transactionId: result.transactionId,
          processId: result.processId,
          status: result.status,
          result: result.result,
          error: result.error,
          timestamp: new Date(result.timestamp).toISOString()
        });
      } catch (error) {
        console.error('Error processing request:', error);
        res.status(500).json({
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });
    
    // Make payment endpoint
    this.app.post('/api/payment', async (req, res) => {
      try {
        const { processId, amount, userAddress } = req.body;
        
        if (!processId || !amount || !userAddress) {
          return res.status(400).json({
            success: false,
            error: 'Process ID, amount, and user address are required'
          });
        }
        
        // Get account from private key
        const account = this.getAccountFromPrivateKey();
        
        // Get payment service
        const paymentService = new AptosPaymentService({
          moduleAddress: this.moduleAddress,
          aptosClient: this.aptosClient
        });
        
        // Make payment
        const txHash = await paymentService.makePayment(account, {
          processId,
          amount: parseInt(amount)
        });
        
        // Return response
        res.status(200).json({
          success: true,
          transactionHash: txHash,
          processId,
          amount,
          userAddress,
          timestamp: new Date().toISOString()
        });
      } catch (error) {
        console.error('Error making payment:', error);
        res.status(500).json({
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });
    
    // Verify payment endpoint
    this.app.get('/api/payment/verify/:processId/:userAddress', async (req, res) => {
      try {
        const { processId, userAddress } = req.params;
        
        // Get payment service
        const paymentService = new AptosPaymentService({
          moduleAddress: this.moduleAddress,
          aptosClient: this.aptosClient
        });
        
        // Verify payment
        const verified = await paymentService.verifyPayment(processId, userAddress);
        
        // Return response
        res.status(200).json({
          success: true,
          verified,
          processId,
          userAddress,
          timestamp: new Date().toISOString()
        });
      } catch (error) {
        console.error('Error verifying payment:', error);
        res.status(500).json({
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });
    
    // Get process endpoint
    this.app.get('/api/process/:processId', async (req, res) => {
      try {
        const { processId } = req.params;
        
        // Get discovery service
        const discoveryService = new AptosDiscoveryService({
          moduleAddress: this.moduleAddress,
          aptosClient: this.aptosClient
        });
        
        // Get process details
        const process = await discoveryService.getProcess(processId);
        
        if (!process) {
          return res.status(404).json({
            success: false,
            error: `Process ${processId} not found`
          });
        }
        
        // Return response
        res.status(200).json({
          success: true,
          process,
          timestamp: new Date().toISOString()
        });
      } catch (error) {
        console.error('Error getting process:', error);
        res.status(500).json({
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });
    
    // List processes endpoint
    this.app.get('/api/processes', async (req, res) => {
      try {
        const { owner, tag, status } = req.query;
        
        // Get discovery service
        const discoveryService = new AptosDiscoveryService({
          moduleAddress: this.moduleAddress,
          aptosClient: this.aptosClient
        });
        
        // Build search options
        const searchOptions: any = {};
        if (owner) searchOptions.owner = owner as string;
        if (tag) searchOptions.tags = [tag as string];
        if (status) searchOptions.status = status as string;
        
        // List processes
        const processes = await discoveryService.listProcesses(searchOptions);
        
        // Return response
        res.status(200).json({
          success: true,
          processes,
          count: processes.length,
          timestamp: new Date().toISOString()
        });
      } catch (error) {
        console.error('Error listing processes:', error);
        res.status(500).json({
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });
  }
  
  /**
   * Start the server
   */
  public start(): void {
    this.app.listen(this.port, () => {
      console.log(`🚀 Agent Gateway Server running on port ${this.port}`);
      console.log(`📡 Connected to Aptos blockchain`);
      console.log(`📝 Module address: ${this.moduleAddress}`);
    });
  }
  
  /**
   * Get Aptos network URL
   */
  private getNetworkUrl(network: string): string {
    const networks: Record<string, string> = {
      mainnet: 'https://fullnode.mainnet.aptoslabs.com/v1',
      testnet: 'https://fullnode.testnet.aptoslabs.com/v1',
      devnet: 'https://fullnode.devnet.aptoslabs.com/v1'
    };
    
    return networks[network] || networks.testnet;
  }
  
  /**
   * Get account from private key
   * 
   * This is a placeholder for demo purposes
   * In production, account management would be done securely
   */
  protected getAccountFromPrivateKey(): any {
    // This is a placeholder - in a real implementation, you would securely
    // manage the private key and return an AptosAccount
    throw new Error('getAccountFromPrivateKey not implemented');
  }
}

/**
 * Create and start the gateway server
 */
if (require.main === module) {
  // This code only runs if the file is executed directly
  const port = parseInt(process.env.PORT || '3000');
  const moduleAddress = process.env.APTOS_MODULE_ADDRESS;
  const aptosNetwork = process.env.APTOS_NETWORK || 'testnet';
  const privateKey = process.env.APTOS_PRIVATE_KEY;
  
  if (!moduleAddress) {
    console.error('APTOS_MODULE_ADDRESS environment variable is required');
    process.exit(1);
  }
  
  if (!privateKey) {
    console.error('APTOS_PRIVATE_KEY environment variable is required');
    process.exit(1);
  }
  
  const server = new AgentGatewayServer({
    port,
    moduleAddress,
    aptosNetwork,
    privateKey
  });
  
  server.start();
}

================
File: src/api/custom-agent-gateway.ts
================
import { AptosAccount } from 'aptos';

import { AgentGatewayServer, GatewayConfig } from './agent-gateway';

/**
 * Custom Agent Gateway Server that implements the missing methods
 */
export class CustomAgentGatewayServer extends AgentGatewayServer {
  constructor(config: GatewayConfig) {
    super(config);
  }
  
  /**
   * Override the protected method with a working implementation
   */
  protected getAccountFromPrivateKey(): any {
    const privateKeyHex = process.env.APTOS_PRIVATE_KEY;
    if (!privateKeyHex) {
      throw new Error('APTOS_PRIVATE_KEY environment variable is required');
    }
    
    // Convert hex string to Uint8Array and create account
    const privateKeyBytes = new Uint8Array(
      Buffer.from(privateKeyHex.replace(/^0x/i, ''), 'hex')
    );
    
    return new AptosAccount(privateKeyBytes);
  }
}

================
File: src/bin/a3.ts
================
#!/usr/bin/env node

/**
 * A3 Command Line Interface
 * 
 * This is the main entry point for the A3 CLI, which provides
 * access to all A3 platform functionality from the command line.
 */

import { createCliProgram } from '../cli';

// Run the CLI program
createCliProgram().parse(process.argv);

================
File: src/cli/index.ts
================
import { Command } from 'commander';

import { configureRegisterProcessCommand } from './register-process-command';

/**
 * Create and configure the root CLI program
 */
export function createCliProgram(): Command {
  const program = new Command()
    .name('a3')
    .description('A3 Command Line Interface')
    .version('0.1.0');
  
  // Add register command
  program.addCommand(configureRegisterProcessCommand());
  
  return program;
}

// Export individual command configurators
export { configureRegisterProcessCommand };

================
File: src/cli/register-process-cli.ts
================
#!/usr/bin/env node
import fs from 'fs';
import path from 'path';

import { AptosAccount, AptosClient, HexString } from 'aptos';
import { Command } from 'commander';
import dotenv from 'dotenv';
import inquirer from 'inquirer';
import { v4 as uuid } from 'uuid';

import { AptosDiscoveryService } from '../discovery/aptos-discovery-service';

// Load environment variables
dotenv.config();

// Create a new program
const program = new Command();

// Set program info
program
  .name('a3-register-process')
  .description('CLI tool for registering agent processes with the A3 platform')
  .version('1.0.0');

// Register command
program
  .command('register')
  .description('Register a new agent process')
  .option('-c, --config <path>', 'Path to process config file')
  .option('-p, --private-key <key>', 'Private key for the creator account')
  .option('-m, --module-address <address>', 'Module address')
  .option('-n, --network <network>', 'Aptos network (mainnet, testnet, devnet)', 'testnet')
  .action(async (options) => {
    try {
      // Get account from private key
      const privateKey = options.privateKey || process.env.APTOS_PRIVATE_KEY;
      if (!privateKey) {
        console.error('Error: Private key is required. Provide it with --private-key or set APTOS_PRIVATE_KEY in your environment.');
        process.exit(1);
      }
      
      // Parse private key and create account
      const hexKey = privateKey.startsWith('0x') ? privateKey : `0x${privateKey}`;
      const account = new AptosAccount(HexString.ensure(hexKey).toUint8Array());
      
      // Get module address
      const moduleAddress = options.moduleAddress || process.env.APTOS_MODULE_ADDRESS;
      if (!moduleAddress) {
        console.error('Error: Module address is required. Provide it with --module-address or set APTOS_MODULE_ADDRESS in your environment.');
        process.exit(1);
      }
      
      // Get network and create client
      const network = options.network || process.env.APTOS_NETWORK || 'testnet';
      const networkUrl = getNetworkUrl(network);
      const client = new AptosClient(networkUrl);
      
      // Process config
      let processConfig: any = {};
      
      // If config file is provided, load it
      if (options.config) {
        const configPath = path.resolve(options.config);
        if (!fs.existsSync(configPath)) {
          console.error(`Error: Config file not found at ${configPath}`);
          process.exit(1);
        }
        
        try {
          const fileContent = fs.readFileSync(configPath, 'utf8');
          processConfig = JSON.parse(fileContent);
        } catch (error) {
          console.error(`Error parsing config file: ${error instanceof Error ? error.message : 'Unknown error'}`);
          process.exit(1);
        }
      } else {
        // Prompt for details if no config file
        processConfig = await promptForProcessDetails();
      }
      
      // Create discovery service
      const discoveryService = new AptosDiscoveryService({
        moduleAddress,
        aptosClient: client
      });
      
      console.log(`\nRegistering process on ${network}...`);
      
      // Register process
      const processId = await discoveryService.registerProcess(account, {
        id: uuid(),
        name: processConfig.name,
        description: processConfig.description,
        owner: account.address().toString(),
        agents: processConfig.agents,
        workflows: processConfig.workflows,
        tags: processConfig.tags,
        status: processConfig.status || 'active',
        pricing: processConfig.pricing,
        url: processConfig.url,
        created_at: Date.now(),
        updated_at: Date.now()
      });
      
      console.log(`\n✅ Process registered successfully!`);
      console.log(`Process ID: ${processId}`);
      console.log(`\nYou can now call this process through the A3 platform.`);
      
    } catch (error) {
      console.error(`\n❌ Error registering process: ${error instanceof Error ? error.message : 'Unknown error'}`);
      process.exit(1);
    }
  });

// Update command
program
  .command('update')
  .description('Update an existing agent process')
  .requiredOption('-i, --id <id>', 'Process ID to update')
  .option('-c, --config <path>', 'Path to updated process config file')
  .option('-p, --private-key <key>', 'Private key for the creator account')
  .option('-m, --module-address <address>', 'Module address')
  .option('-n, --network <network>', 'Aptos network (mainnet, testnet, devnet)', 'testnet')
  .action(async (options) => {
    try {
      // Get account from private key
      const privateKey = options.privateKey || process.env.APTOS_PRIVATE_KEY;
      if (!privateKey) {
        console.error('Error: Private key is required. Provide it with --private-key or set APTOS_PRIVATE_KEY in your environment.');
        process.exit(1);
      }
      
      // Parse private key and create account
      const hexKey = privateKey.startsWith('0x') ? privateKey : `0x${privateKey}`;
      const account = new AptosAccount(HexString.ensure(hexKey).toUint8Array());
      
      // Get module address
      const moduleAddress = options.moduleAddress || process.env.APTOS_MODULE_ADDRESS;
      if (!moduleAddress) {
        console.error('Error: Module address is required. Provide it with --module-address or set APTOS_MODULE_ADDRESS in your environment.');
        process.exit(1);
      }
      
      // Get network and create client
      const network = options.network || process.env.APTOS_NETWORK || 'testnet';
      const networkUrl = getNetworkUrl(network);
      const client = new AptosClient(networkUrl);
      
      // Create discovery service
      const discoveryService = new AptosDiscoveryService({
        moduleAddress,
        aptosClient: client
      });
      
      // Get current process
      console.log(`Fetching current process details for ${options.id}...`);
      const currentProcess = await discoveryService.getProcess(options.id);
      
      if (!currentProcess) {
        console.error(`Error: Process with ID ${options.id} not found.`);
        process.exit(1);
      }
      
      // Process config
      let processConfig: any = {};
      
      // If config file is provided, load it
      if (options.config) {
        const configPath = path.resolve(options.config);
        if (!fs.existsSync(configPath)) {
          console.error(`Error: Config file not found at ${configPath}`);
          process.exit(1);
        }
        
        try {
          const fileContent = fs.readFileSync(configPath, 'utf8');
          processConfig = JSON.parse(fileContent);
        } catch (error) {
          console.error(`Error parsing config file: ${error instanceof Error ? error.message : 'Unknown error'}`);
          process.exit(1);
        }
      } else {
        // Prompt for details if no config file, using current values as defaults
        processConfig = await promptForProcessDetails(currentProcess);
      }
      
      console.log(`\nUpdating process on ${network}...`);
      
      // Update process
      await discoveryService.updateProcess(account, options.id, {
        name: processConfig.name,
        description: processConfig.description,
        agents: processConfig.agents,
        workflows: processConfig.workflows,
        tags: processConfig.tags,
        status: processConfig.status || 'active',
        pricing: processConfig.pricing,
        url: processConfig.url
      });
      
      console.log(`\n✅ Process updated successfully!`);
      console.log(`Process ID: ${options.id}`);
      
    } catch (error) {
      console.error(`\n❌ Error updating process: ${error instanceof Error ? error.message : 'Unknown error'}`);
      process.exit(1);
    }
  });

// Deregister command
program
  .command('deregister')
  .description('Deregister an existing agent process')
  .requiredOption('-i, --id <id>', 'Process ID to deregister')
  .option('-p, --private-key <key>', 'Private key for the creator account')
  .option('-m, --module-address <address>', 'Module address')
  .option('-n, --network <network>', 'Aptos network (mainnet, testnet, devnet)', 'testnet')
  .action(async (options) => {
    try {
      // Get account from private key
      const privateKey = options.privateKey || process.env.APTOS_PRIVATE_KEY;
      if (!privateKey) {
        console.error('Error: Private key is required. Provide it with --private-key or set APTOS_PRIVATE_KEY in your environment.');
        process.exit(1);
      }
      
      // Parse private key and create account
      const hexKey = privateKey.startsWith('0x') ? privateKey : `0x${privateKey}`;
      const account = new AptosAccount(HexString.ensure(hexKey).toUint8Array());
      
      // Get module address
      const moduleAddress = options.moduleAddress || process.env.APTOS_MODULE_ADDRESS;
      if (!moduleAddress) {
        console.error('Error: Module address is required. Provide it with --module-address or set APTOS_MODULE_ADDRESS in your environment.');
        process.exit(1);
      }
      
      // Get network and create client
      const network = options.network || process.env.APTOS_NETWORK || 'testnet';
      const networkUrl = getNetworkUrl(network);
      const client = new AptosClient(networkUrl);
      
      // Create discovery service
      const discoveryService = new AptosDiscoveryService({
        moduleAddress,
        aptosClient: client
      });
      
      // Confirm deregistration
      const { confirm } = await inquirer.prompt([
        {
          type: 'confirm',
          name: 'confirm',
          message: `Are you sure you want to deregister process ${options.id}?`,
          default: false
        }
      ]);
      
      if (!confirm) {
        console.log('Deregistration cancelled.');
        process.exit(0);
      }
      
      console.log(`\nDeregistering process on ${network}...`);
      
      // Deregister process
      await discoveryService.deregisterProcess(account, options.id);
      
      console.log(`\n✅ Process deregistered successfully!`);
      console.log(`Process ID: ${options.id}`);
      
    } catch (error) {
      console.error(`\n❌ Error deregistering process: ${error instanceof Error ? error.message : 'Unknown error'}`);
      process.exit(1);
    }
  });

// List command
program
  .command('list')
  .description('List registered agent processes')
  .option('-o, --owner <address>', 'Filter by owner address')
  .option('-t, --tag <tag>', 'Filter by tag')
  .option('-s, --status <status>', 'Filter by status')
  .option('-m, --module-address <address>', 'Module address')
  .option('-n, --network <network>', 'Aptos network (mainnet, testnet, devnet)', 'testnet')
  .action(async (options) => {
    try {
      // Get module address
      const moduleAddress = options.moduleAddress || process.env.APTOS_MODULE_ADDRESS;
      if (!moduleAddress) {
        console.error('Error: Module address is required. Provide it with --module-address or set APTOS_MODULE_ADDRESS in your environment.');
        process.exit(1);
      }
      
      // Get network and create client
      const network = options.network || process.env.APTOS_NETWORK || 'testnet';
      const networkUrl = getNetworkUrl(network);
      const client = new AptosClient(networkUrl);
      
      // Create discovery service
      const discoveryService = new AptosDiscoveryService({
        moduleAddress,
        aptosClient: client
      });
      
      // Build search options
      const searchOptions: any = {};
      if (options.owner) searchOptions.owner = options.owner;
      if (options.tag) searchOptions.tags = [options.tag];
      if (options.status) searchOptions.status = options.status;
      
      console.log(`Listing processes on ${network}...`);
      
      // List processes
      const processes = await discoveryService.listProcesses(searchOptions);
      
      console.log(`\nFound ${processes.length} processes:`);
      
      // Display processes
      processes.forEach((process, index) => {
        console.log(`\n${index + 1}. ${process.name} (ID: ${process.id})`);
        console.log(`   Description: ${process.description}`);
        console.log(`   Owner: ${process.owner}`);
        console.log(`   Status: ${process.status}`);
        console.log(`   Tags: ${process.tags.join(', ')}`);
        console.log(`   URL: ${process.url}`);
        console.log(`   Created: ${new Date(process.created_at).toLocaleString()}`);
      });
      
    } catch (error) {
      console.error(`\n❌ Error listing processes: ${error instanceof Error ? error.message : 'Unknown error'}`);
      process.exit(1);
    }
  });

// Helper functions

/**
 * Get Aptos network URL
 */
function getNetworkUrl(network: string): string {
  const networks: Record<string, string> = {
    mainnet: 'https://fullnode.mainnet.aptoslabs.com/v1',
    testnet: 'https://fullnode.testnet.aptoslabs.com/v1',
    devnet: 'https://fullnode.devnet.aptoslabs.com/v1'
  };
  
  return networks[network] || networks.testnet;
}

/**
 * Prompt for process details
 */
async function promptForProcessDetails(currentProcess?: any): Promise<any> {
  const questions = [
    {
      type: 'input',
      name: 'name',
      message: 'Process name:',
      default: currentProcess?.name || ''
    },
    {
      type: 'input',
      name: 'description',
      message: 'Process description:',
      default: currentProcess?.description || ''
    },
    {
      type: 'input',
      name: 'url',
      message: 'Process URL:',
      default: currentProcess?.url || '',
      validate: (input: string) => {
        if (!input) return 'URL is required';
        try {
          new URL(input);
          return true;
        } catch (error) {
          return 'Please enter a valid URL';
        }
      }
    },
    {
      type: 'input',
      name: 'tags',
      message: 'Process tags (comma-separated):',
      default: currentProcess?.tags?.join(',') || '',
      filter: (input: string) => input.split(',').map(tag => tag.trim()).filter(Boolean)
    },
    {
      type: 'list',
      name: 'status',
      message: 'Process status:',
      choices: ['active', 'inactive', 'maintenance'],
      default: currentProcess?.status || 'active'
    },
    {
      type: 'input',
      name: 'agents',
      message: 'Agent addresses (comma-separated):',
      default: currentProcess?.agents?.join(',') || '',
      filter: (input: string) => input.split(',').map(agent => agent.trim()).filter(Boolean)
    },
    {
      type: 'input',
      name: 'workflows',
      message: 'Workflow IDs (comma-separated):',
      default: currentProcess?.workflows?.join(',') || '',
      filter: (input: string) => input.split(',').map(workflow => workflow.trim()).filter(Boolean)
    },
    {
      type: 'number',
      name: 'taskPrice',
      message: 'Task price:',
      default: currentProcess?.pricing?.taskPrice || 0
    },
    {
      type: 'input',
      name: 'currency',
      message: 'Currency:',
      default: currentProcess?.pricing?.currency || 'APT'
    },
    {
      type: 'input',
      name: 'paymentAddress',
      message: 'Payment address:',
      default: currentProcess?.pricing?.paymentAddress || ''
    },
    {
      type: 'confirm',
      name: 'requiresPrepayment',
      message: 'Requires prepayment?',
      default: currentProcess?.pricing?.requiresPrepayment || false
    }
  ];
  
  const answers = await inquirer.prompt(questions);
  
  // Format pricing
  answers.pricing = {
    taskPrice: answers.taskPrice,
    currency: answers.currency,
    paymentAddress: answers.paymentAddress,
    requiresPrepayment: answers.requiresPrepayment
  };
  
  // Remove individual pricing fields
  delete answers.taskPrice;
  delete answers.currency;
  delete answers.paymentAddress;
  delete answers.requiresPrepayment;
  
  return answers;
}

// Parse arguments
program.parse(process.argv);

// If no arguments, show help
if (!process.argv.slice(2).length) {
  program.outputHelp();
}

================
File: src/cli/register-process-command.ts
================
import { Command } from 'commander';

import { ExtendedProcess, createAptosServices, CreatorProfile } from '..';
import { Logger } from '../utils';

const logger = new Logger('Register Process');

/**
 * Register a process with the Aptos blockchain
 */
export async function registerProcess(
  name: string, 
  description: string, 
  tags: string[] = [],
  creatorProfile?: CreatorProfile,
  pricing?: {
    taskPrice: string;
    currency?: string;
    paymentAddress?: string;
    requiresPrepayment?: boolean;
  }
): Promise<{ success: boolean; processId: string }> {
  logger.section('Process Registration');
  
  try {
    logger.info('Creating Aptos services...');
    // Create services using factory function
    const { discoveryService, paymentService } = createAptosServices();
    logger.success('Services created');
    
    const owner = process.env.PROCESS_OWNER || 'custom-user';
    
    logger.info(`Creating process "${name}"...`);
    // Create an extended process with the services
    const processInstance = new ExtendedProcess({
      // Provide the services
      discoveryService,
      paymentService,
      
      // Provide metadata for the process
      metadata: {
        name,
        description,
        tags: [...tags],
        owner,
        creatorProfile,
        pricing: pricing ? {
          ...pricing,
          requiresPrepayment: pricing.requiresPrepayment ?? true
        } : undefined
      }
    });
    
    logger.success('Process created');
    logger.detail('Process ID', processInstance.getProcessId());
    
    logger.info('Initializing and registering process...');
    // Initialize the process (this will register it with the discovery service)
    await processInstance.initialize();
    logger.success('Process initialized and registered on Aptos blockchain');
    
    // Get network and module address from environment variables
    const network = process.env.APTOS_NETWORK || 'testnet';
    const moduleAddress = process.env.APTOS_MODULE_ADDRESS;
    
    logger.info('Process registration successful!');
    logger.info(`View your process on the Aptos Explorer:`);
    logger.info(`https://${network}.aptos.dev/account/${moduleAddress}`);
    
    return {
      success: true,
      processId: processInstance.getProcessId()
    };
  } catch (error) {
    logger.error('Process registration failed', error);
    throw error;
  }
}

/**
 * Configure the register process command
 */
export function configureRegisterProcessCommand(): Command {
  const command = new Command('register')
    .description('Register a process with the Aptos blockchain')
    .option('--name <name>', 'Name of the process', 'Custom Process')
    .option('--description <description>', 'Description of the process', 'A process registered with A3 on Aptos')
    .option('--tags <tags>', 'Comma-separated list of tags', (val) => val.split(','), [])
    .option('--creator-name <name>', 'Name of the creator')
    .option('--creator-description <description>', 'Description of the creator')
    .option('--creator-wallet <address>', 'Wallet address of the creator')
    .option('--creator-website <url>', 'Website of the creator')
    .option('--creator-social <socials>', 'Comma-separated list of social media links in format platform:url')
    .option('--task-price <price>', 'Price for a task')
    .option('--currency <currency>', 'Currency for the task price', 'APT')
    .option('--payment-address <address>', 'Address to receive payments')
    .option('--requires-prepayment <boolean>', 'Whether the process requires prepayment', (val) => val === 'true', true)
    .action(async (options) => {
      try {
        // Parse creator profile if provided
        let creatorProfile: CreatorProfile | undefined;
        if (options.creatorName || options.creatorDescription || options.creatorWallet || options.creatorWebsite || options.creatorSocial) {
          creatorProfile = {};
          
          if (options.creatorName) creatorProfile.name = options.creatorName;
          if (options.creatorDescription) creatorProfile.description = options.creatorDescription;
          if (options.creatorWallet) creatorProfile.walletAddress = options.creatorWallet;
          if (options.creatorWebsite) creatorProfile.website = options.creatorWebsite;
          
          if (options.creatorSocial) {
            creatorProfile.social = {};
            const socialParts = options.creatorSocial.split(',');
            for (const part of socialParts) {
              const [platform, url] = part.split(':');
              if (platform && url && creatorProfile.social) {
                creatorProfile.social[platform] = url;
              }
            }
          }
        }
        
        // Parse pricing if provided
        let pricing: {
          taskPrice: string;
          currency?: string;
          paymentAddress?: string;
          requiresPrepayment?: boolean;
        } | undefined;
        
        if (options.taskPrice) {
          pricing = {
            taskPrice: options.taskPrice,
            currency: options.currency,
            paymentAddress: options.paymentAddress,
            requiresPrepayment: options.requiresPrepayment
          };
        }
        
        // Register the process
        await registerProcess(
          options.name,
          options.description,
          options.tags,
          creatorProfile,
          pricing
        );
        
        process.exit(0);
      } catch (error) {
        logger.error('Registration failed', error);
        process.exit(1);
      }
    });
    
  return command;
}

================
File: src/contract/aptos-contract-service.ts
================
import { exec } from 'child_process';
import fs from 'fs';
import path from 'path';
import { promisify } from 'util';

import { AptosClient } from 'aptos';

import { ContractConfig, ContractDeploymentResult, ContractService } from './interfaces';

const execPromise = promisify(exec);

/**
 * Aptos Contract Service implementation
 * 
 * Handles contract deployment and interaction with the Aptos blockchain
 */
export class AptosContractService implements ContractService {
  private config: ContractConfig;
  private aptosClient: AptosClient;
  
  /**
   * Create a new Aptos Contract Service
   * 
   * @param config Aptos contract configuration
   */
  constructor(config: ContractConfig) {
    this.config = config;
    this.aptosClient = new AptosClient(config.nodeUrl || 'https://fullnode.testnet.aptoslabs.com/v1');
  }
  
  /**
   * Get the AptosClient instance
   * 
   * @returns AptosClient instance used by this service
   */
  getAptosClient(): AptosClient {
    return this.aptosClient;
  }
  
  /**
   * Deploy a smart contract to the Aptos blockchain
   * 
   * @param contractPath Path to the contract file
   * @returns Promise resolving to contract deployment result
   */
  async deployContract(contractPath: string): Promise<ContractDeploymentResult> {
    try {
      // Check if file exists
      if (!fs.existsSync(contractPath)) {
        return {
          success: false,
          error: `Contract file not found: ${contractPath}`
        };
      }
      
      // Get directory and filename from path
      const contractDir = path.dirname(contractPath);
      const contractName = path.basename(contractPath, path.extname(contractPath));
      
      // Create temp file with private key
      const privateKeyPath = path.join(contractDir, '.temp-key.txt');
      fs.writeFileSync(privateKeyPath, this.config.privateKey);
      
      try {
        // Run deployment command
        const deployCommand = `cd ${contractDir} && aptos move publish ` +
          `--package-dir . ` +
          `--named-addresses a3=${this.config.moduleAddress} ` +
          `--private-key-file ${privateKeyPath} ` +
          `--url ${this.config.nodeUrl || `https://fullnode.${this.config.network}.aptoslabs.com/v1`}`;
        
        console.log('Executing command:', deployCommand.replace(this.config.privateKey, '[PRIVATE_KEY]'));
        
        const { stdout, stderr } = await execPromise(deployCommand);
        
        console.log('Deployment stdout:', stdout);
        if (stderr) {
          console.log('Deployment stderr:', stderr);
        }
        
        // Parse the output to get the transaction hash
        const txHashMatch = stdout.match(/Transaction hash: (0x[a-f0-9]+)/i);
        const txHash = txHashMatch ? txHashMatch[1] : undefined;
        
        return {
          success: true,
          transactionHash: txHash,
          moduleAddress: this.config.moduleAddress,
          timestamp: new Date().toISOString()
        };
      } finally {
        // Clean up private key file
        if (fs.existsSync(privateKeyPath)) {
          fs.unlinkSync(privateKeyPath);
        }
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  
  /**
   * Execute a contract function on the Aptos blockchain
   * 
   * @param functionName Name of the function to execute
   * @param args Arguments for the function
   * @returns Promise resolving to the transaction hash
   */
  async executeFunction(functionName: string, args: any[]): Promise<string> {
    try {
      // Format the arguments as a JSON string
      const argsJson = JSON.stringify(args);
      
      // Create temp file with private key
      const tempDir = fs.mkdtempSync('aptos-');
      const privateKeyPath = path.join(tempDir, 'key.txt');
      fs.writeFileSync(privateKeyPath, this.config.privateKey);
      
      try {
        // Run execution command
        const { stdout } = await execPromise(
          `aptos move run ` +
          `--function ${this.config.moduleAddress}::${functionName} ` +
          `--args ${argsJson} ` +
          `--private-key-file ${privateKeyPath} ` +
          `--url ${this.config.nodeUrl || `https://${this.config.network}.aptoslabs.com/v1`}`
        );
        
        // Parse the output to get the transaction hash
        const txHashMatch = stdout.match(/Transaction hash: (0x[a-f0-9]+)/i);
        if (!txHashMatch) {
          throw new Error('Could not find transaction hash in output');
        }
        
        return txHashMatch[1];
      } finally {
        // Clean up temp directory
        if (fs.existsSync(tempDir)) {
          fs.rmdirSync(tempDir, { recursive: true });
        }
      }
    } catch (error) {
      console.error('Error executing contract function:', error);
      throw error;
    }
  }
  
  /**
   * Query contract data from the Aptos blockchain
   * 
   * @param functionName Name of the function to query
   * @param args Arguments for the function
   * @returns Promise resolving to the query result
   */
  async queryFunction(functionName: string, args: any[]): Promise<any> {
    try {
      // Format the arguments as a JSON string
      const argsJson = JSON.stringify(args);
      
      // Run query command
      const { stdout } = await execPromise(
        `aptos move view ` +
        `--function ${this.config.moduleAddress}::${functionName} ` +
        `--args ${argsJson} ` +
        `--url ${this.config.nodeUrl || `https://${this.config.network}.aptoslabs.com/v1`}`
      );
      
      // Parse the output as JSON
      return JSON.parse(stdout);
    } catch (error) {
      console.error('Error querying contract function:', error);
      throw error;
    }
  }
  
  /**
   * Get the current account balance
   * 
   * @param address Wallet address to check balance (default: config.moduleAddress)
   * @returns Promise resolving to the balance as a string
   */
  async getBalance(address?: string): Promise<string> {
    try {
      const targetAddress = address || this.config.moduleAddress;
      
      // Run balance query command
      const { stdout } = await execPromise(
        `aptos account list ` +
        `--account ${targetAddress} ` +
        `--url ${this.config.nodeUrl || `https://${this.config.network}.aptoslabs.com/v1`}`
      );
      
      // Parse the output to get the balance
      const balanceMatch = stdout.match(/Coin balance: (\d+(\.\d+)?)/i);
      if (!balanceMatch) {
        throw new Error('Could not find balance in output');
      }
      
      return balanceMatch[1];
    } catch (error) {
      console.error('Error getting account balance:', error);
      throw error;
    }
  }
}

================
File: src/contract/interfaces.ts
================
/**
 * Blockchain contract configuration
 */
export interface ContractConfig {
  network: string;
  moduleAddress: string;
  privateKey: string;
  nodeUrl?: string;
  faucetUrl?: string;
}

/**
 * Contract deployment result
 */
export interface ContractDeploymentResult {
  success: boolean;
  transactionHash?: string;
  moduleAddress?: string;
  timestamp?: string;
  error?: string;
}

/**
 * Contract service interface for managing blockchain interactions
 */
export interface ContractService {
  /**
   * Deploy a smart contract to the blockchain
   * 
   * @param contractPath Path to the contract file
   * @returns Promise resolving to contract deployment result
   */
  deployContract(contractPath: string): Promise<ContractDeploymentResult>;
  
  /**
   * Execute a contract function
   * 
   * @param functionName Name of the function to execute
   * @param args Arguments for the function
   * @returns Promise resolving to the transaction hash
   */
  executeFunction(functionName: string, args: any[]): Promise<string>;
  
  /**
   * Query contract data from the blockchain
   * 
   * @param functionName Name of the function to query
   * @param args Arguments for the function
   * @returns Promise resolving to the query result
   */
  queryFunction(functionName: string, args: any[]): Promise<any>;
  
  /**
   * Get the current account balance
   * 
   * @param address Wallet address to check balance
   * @returns Promise resolving to the balance as a string
   */
  getBalance(address?: string): Promise<string>;
  
  /**
   * Get the AptosClient instance
   * 
   * @returns AptosClient instance used by this service
   */
  getAptosClient(): any;
}

================
File: src/creator/interfaces.ts
================
/**
 * Social media links for a creator profile
 */
export interface SocialLinks {
  [platform: string]: string;
}

/**
 * Creator profile information
 */
export interface CreatorProfile {
  /** Creator's name */
  name?: string;
  
  /** Description of the creator */
  description?: string;
  
  /** Wallet address for the creator */
  walletAddress?: string;
  
  /** Creator's website URL */
  website?: string;
  
  /** Social media links */
  social?: SocialLinks;
}

/**
 * Creator service interface for managing creator profiles
 */
export interface CreatorService {
  /**
   * Register a new creator profile
   * 
   * @param profile Creator profile information
   * @returns Promise resolving to the creator ID
   */
  registerCreator(profile: CreatorProfile): Promise<string>;
  
  /**
   * Get a creator profile by ID
   * 
   * @param creatorId Creator identifier
   * @returns Promise resolving to the creator profile or null if not found
   */
  getCreator(creatorId: string): Promise<CreatorProfile | null>;
  
  /**
   * Update an existing creator profile
   * 
   * @param creatorId Creator identifier
   * @param profile Updated creator profile information
   */
  updateCreator(creatorId: string, profile: Partial<CreatorProfile>): Promise<void>;
}

================
File: src/discovery/aptos/deploy-contract.ts
================
import { execSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';

// Define Network enum to match the mocked version in discovery-service.ts
export enum Network {
  DEVNET = 'devnet',
  TESTNET = 'testnet',
  MAINNET = 'mainnet'
}

/**
 * Configuration for contract deployment
 */
interface DeployContractConfig {
  /**
   * Network to deploy to (default: testnet)
   */
  network?: Network;
  
  /**
   * Node URL override
   */
  nodeUrl?: string;
  
  /**
   * Private key for deployment
   */
  privateKey: string;
  
  /**
   * Path to the Move module
   */
  modulePath?: string;
  
  /**
   * Path to store the compiled bytecode
   */
  compiledModulePath?: string;
}

/**
 * Deploy the Process Registry smart contract to Aptos blockchain
 * 
 * This function uses the Aptos CLI to deploy the contract.
 * Make sure you have the CLI installed: https://aptos.dev/cli-tools/aptos-cli-tool/install-aptos-cli
 * 
 * @param config Deployment configuration
 * @returns Deployment information
 */
export async function deployProcessRegistry(config: DeployContractConfig) {
  // Generate a temporary profile configuration for deployment
  const tempDir = fs.mkdtempSync(path.join(require('os').tmpdir(), 'aptos-deploy-'));
  const profilePath = path.join(tempDir, '.aptos', 'config.yaml');
  
  // Ensure directory exists
  fs.mkdirSync(path.dirname(profilePath), { recursive: true });
  
  // Set up profile based on network
  const network = config.network || Network.TESTNET;
  const nodeUrl = config.nodeUrl || getDefaultNodeUrl(network);
  
  // Write profile configuration
  const profileContent = `---
profiles:
  default:
    private_key: "${config.privateKey}"
    public_key: "auto"  # Will be derived from private key
    account: "auto"     # Will be derived from private key
    rest_url: "${nodeUrl}"
    faucet_url: "${getFaucetUrl(network)}"
`;
  
  fs.writeFileSync(profilePath, profileContent);
  
  try {
    console.log(`Using Aptos network: ${network}`);
    
    // Compile the Move module
    const modulePath = config.modulePath || path.resolve(__dirname, './process_registry.move');
    const outputDir = path.dirname(modulePath);
    
    console.log('Compiling Move module...');
    execSync(`aptos move compile --package-dir ${outputDir} --save-metadata --named-addresses process_registry=default`, {
      env: { ...process.env, APTOS_CONFIG: profilePath },
      stdio: 'inherit'
    });
    
    // Deploy the module
    console.log('Deploying Process Registry module...');
    const publishOutput = execSync(`aptos move publish --package-dir ${outputDir} --named-addresses process_registry=default`, {
      env: { ...process.env, APTOS_CONFIG: profilePath },
      encoding: 'utf8'
    });
    
    // Extract transaction hash from output
    const txHashMatch = publishOutput.match(/Transaction hash: ([0-9a-f]+)/);
    const transactionHash = txHashMatch ? txHashMatch[1] : 'unknown';
    
    // Get account address
    const accountInfoOutput = execSync('aptos account list', {
      env: { ...process.env, APTOS_CONFIG: profilePath },
      encoding: 'utf8'
    });
    
    const accountMatch = accountInfoOutput.match(/Account: ([0-9a-f]+)/);
    const accountAddress = accountMatch ? accountMatch[1] : 'unknown';
    
    console.log(`✅ Process Registry module deployed successfully!`);
    console.log(`Module address: ${accountAddress}`);
    
    // Initialize the registry
    console.log('Initializing registry...');
    const initOutput = execSync(`aptos move run --function-id ${accountAddress}::process_registry::initialize`, {
      env: { ...process.env, APTOS_CONFIG: profilePath },
      encoding: 'utf8'
    });
    
    const initTxHashMatch = initOutput.match(/Transaction hash: ([0-9a-f]+)/);
    const initTransactionHash = initTxHashMatch ? initTxHashMatch[1] : 'unknown';
    
    console.log(`✅ Process Registry initialized successfully!`);
    
    return {
      accountAddress,
      transactionHash,
      initTransactionHash
    };
  } catch (error) {
    console.error('Error deploying module:', error);
    throw error;
  } finally {
    // Clean up temporary directory
    try {
      fs.rmSync(tempDir, { recursive: true, force: true });
    } catch (e) {
      console.warn('Could not clean up temporary directory:', e);
    }
  }
}

/**
 * Get the default node URL for a network
 */
function getDefaultNodeUrl(network: Network): string {
  switch (network) {
    case Network.DEVNET:
      return 'https://fullnode.devnet.aptoslabs.com/v1';
    case Network.MAINNET:
      return 'https://fullnode.mainnet.aptoslabs.com/v1';
    case Network.TESTNET:
    default:
      return 'https://fullnode.testnet.aptoslabs.com/v1';
  }
}

/**
 * Get the faucet URL for a network
 * Note: Mainnet doesn't have a faucet
 */
function getFaucetUrl(network: Network): string {
  switch (network) {
    case Network.DEVNET:
      return 'https://faucet.devnet.aptoslabs.com';
    case Network.TESTNET:
      return 'https://faucet.testnet.aptoslabs.com';
    case Network.MAINNET:
    default:
      return '';
  }
}

// CLI support
if (require.main === module) {
  // Load from .env file if present
  try {
    require('dotenv').config();
  } catch (e) {
    // Optional dependency
  }
  
  const privateKey = process.env.APTOS_PRIVATE_KEY;
  const network = (process.env.APTOS_NETWORK || 'testnet') as Network;
  const nodeUrl = process.env.APTOS_NODE_URL;
  
  if (!privateKey) {
    console.error('Error: APTOS_PRIVATE_KEY environment variable is required');
    process.exit(1);
  }
  
  deployProcessRegistry({
    privateKey,
    network,
    nodeUrl
  })
    .then(result => {
      console.log('Deployment completed:', result);
      process.exit(0);
    })
    .catch(error => {
      console.error('Deployment failed:', error);
      process.exit(1);
    });
}

================
File: src/discovery/aptos/discovery-service.ts
================
import { DiscoveryService, ProcessMetadata } from '../interfaces';

// Define Network enum if @aptos-labs/ts-sdk is not available
enum Network {
  DEVNET = 'devnet',
  TESTNET = 'testnet',
  MAINNET = 'mainnet'
}

// Basic interfaces for Aptos integration (to be replaced with actual SDK when available)
interface AptosConfig {
  network: Network;
  fullnodeUrl?: string;
}

interface Account {
  address: string;
}

// Simple Aptos client implementation for now (to be replaced with actual SDK)
class Aptos {
  private config: AptosConfig;
  
  constructor(config: AptosConfig) {
    this.config = config;
  }
  
  get transaction() {
    return {
      build: {
        simple: async ({ sender, data }: any) => {
          console.log('Building transaction', { sender, data });
          return { sender, data };
        }
      },
      sign: async ({ signer, transaction }: any) => {
        console.log('Signing transaction', { signer, transaction });
        return { ...transaction, signature: 'mock-signature' };
      },
      submit: {
        simple: async ({ transaction }: any) => {
          console.log('Submitting transaction', { transaction });
          return { hash: 'mock-transaction-hash' };
        }
      },
      wait: async ({ transactionHash }: any) => {
        console.log('Waiting for transaction', { transactionHash });
        return { success: true };
      }
    };
  }
  
  async view({ function: func, typeArguments, functionArguments }: any) {
    console.log('Viewing function', { function: func, typeArguments, functionArguments });
    
    // Mock responses for different functions
    if (func.includes('get_process')) {
      // For getProcess
      return [JSON.stringify({
        id: functionArguments[0],
        name: 'Mock Process',
        description: 'A mock process',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        agents: [],
        workflows: [],
        tags: [],
        owner: 'mock-owner',
        status: 'active'
      })];
    } else if (func.includes('list_processes')) {
      // For listProcesses
      return [['process1', 'process2', 'process3']];
    }
    
    return [null];
  }
}

/**
 * Configuration for Aptos Discovery Service
 */
export interface AptosDiscoveryConfig {
  /**
   * Network to connect to (default: testnet)
   */
  network?: Network;
  
  /**
   * Node URL override
   */
  nodeUrl?: string;
  
  /**
   * Private key for interacting with blockchain
   */
  privateKey: string;
  
  /**
   * Module address where the registry contract is deployed
   */
  moduleAddress?: string;
  
  /**
   * Name of the registry module
   */
  moduleName?: string;
}

/**
 * Aptos blockchain-based discovery service
 * 
 * This service stores process metadata on the Aptos blockchain,
 * enabling process discovery across different instances and environments.
 */
export class AptosDiscoveryService implements DiscoveryService {
  private aptos: Aptos;
  private account: Account;
  private moduleAddress: string;
  private moduleName: string;
  private functionName = 'process_registry';
  
  /**
   * Creates a new Aptos Discovery Service
   * 
   * @param config Service configuration
   */
  constructor(config: AptosDiscoveryConfig) {
    // Initialize Aptos client
    const aptosConfig = {
      network: config.network || Network.TESTNET,
      ...(config.nodeUrl && { fullnodeUrl: config.nodeUrl })
    };
    
    this.aptos = new Aptos(aptosConfig);
    
    // Set up basic account info
    this.account = { address: `0x${config.privateKey.substring(0, 10)}...` };
    
    // Set module information
    this.moduleAddress = config.moduleAddress || this.account.address;
    this.moduleName = config.moduleName || 'process_registry';
    
    console.log(`Initialized Aptos Discovery Service with account ${this.account.address}`);
  }
  
  /**
   * Register a process with the Aptos blockchain registry
   * 
   * @param processId Unique process identifier
   * @param metadata Process metadata
   */
  async registerProcess(processId: string, metadata: ProcessMetadata): Promise<void> {
    console.log(`Registering process ${processId} with Aptos registry`);
    
    try {
      // Convert metadata to a format suitable for blockchain storage
      const processData = JSON.stringify(metadata);
      
      // Call the smart contract function to register the process
      const transaction = await this.aptos.transaction.build.simple({
        sender: this.account.address,
        data: {
          function: `${this.moduleAddress}::${this.moduleName}::register_process`,
          typeArguments: [],
          functionArguments: [processId, processData]
        }
      });
      
      const signedTx = await this.aptos.transaction.sign({
        signer: this.account,
        transaction
      });
      
      const pendingTx = await this.aptos.transaction.submit.simple({
        transaction: signedTx
      });
      
      // Wait for transaction confirmation
      await this.aptos.transaction.wait({
        transactionHash: pendingTx.hash
      });
      
      console.log(`Process ${processId} registered successfully`);
    } catch (error) {
      console.error(`Failed to register process: ${error}`);
      throw new Error(`Failed to register process: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Update process metadata in the Aptos blockchain registry
   * 
   * @param processId Unique process identifier
   * @param metadata Updated process metadata
   */
  async updateProcess(processId: string, metadata: Partial<ProcessMetadata>): Promise<void> {
    console.log(`Updating process ${processId} in Aptos registry`);
    
    try {
      // First fetch the current process data
      const currentProcess = await this.getProcess(processId);
      
      if (!currentProcess) {
        throw new Error(`Process ${processId} not found`);
      }
      
      // Merge the current data with the updates
      const updatedMetadata = {
        ...currentProcess,
        ...metadata,
        updatedAt: new Date().toISOString()
      };
      
      // Convert metadata to a format suitable for blockchain storage
      const processData = JSON.stringify(updatedMetadata);
      
      // Call the smart contract function to update the process
      const transaction = await this.aptos.transaction.build.simple({
        sender: this.account.address,
        data: {
          function: `${this.moduleAddress}::${this.moduleName}::update_process`,
          typeArguments: [],
          functionArguments: [processId, processData]
        }
      });
      
      const signedTx = await this.aptos.transaction.sign({
        signer: this.account,
        transaction
      });
      
      const pendingTx = await this.aptos.transaction.submit.simple({
        transaction: signedTx
      });
      
      // Wait for transaction confirmation
      await this.aptos.transaction.wait({
        transactionHash: pendingTx.hash
      });
      
      console.log(`Process ${processId} updated successfully`);
    } catch (error) {
      console.error(`Failed to update process: ${error}`);
      throw new Error(`Failed to update process: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Retrieve process metadata from the Aptos blockchain registry
   * 
   * @param processId Unique process identifier
   */
  async getProcess(processId: string): Promise<ProcessMetadata | null> {
    console.log(`Retrieving process ${processId} from Aptos registry`);
    
    try {
      // Call the smart contract view function to get the process data
      const response = await this.aptos.view({
        function: `${this.moduleAddress}::${this.moduleName}::get_process`,
        typeArguments: [],
        functionArguments: [processId]
      });
      
      if (!response || !response[0]) {
        return null;
      }
      
      // Parse the process data from blockchain format
      const processData = response[0] as string;
      const metadata = JSON.parse(processData) as ProcessMetadata;
      
      console.log(`Process ${processId} retrieved successfully`);
      return metadata;
    } catch (error) {
      console.error(`Failed to retrieve process: ${error}`);
      // Return null for "not found" condition
      if (error instanceof Error && error.message.includes('resource not found')) {
        return null;
      }
      throw new Error(`Failed to retrieve process: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * List processes matching the specified filters
   * 
   * @param filters Optional filters to apply
   */
  async listProcesses(filters?: Record<string, any>): Promise<ProcessMetadata[]> {
    console.log(`Listing processes from Aptos registry with filters: ${JSON.stringify(filters)}`);
    
    try {
      // Call the smart contract view function to list processes
      const response = await this.aptos.view({
        function: `${this.moduleAddress}::${this.moduleName}::list_processes`,
        typeArguments: [],
        functionArguments: []
      });
      
      if (!response || !response[0]) {
        return [];
      }
      
      // Parse the list of processes
      const processList = response[0] as string[];
      const processes: ProcessMetadata[] = [];
      
      // Fetch each process's metadata
      for (const processId of processList) {
        const metadata = await this.getProcess(processId);
        if (metadata) {
          // Apply filters if provided
          if (filters) {
            let match = true;
            for (const [key, value] of Object.entries(filters)) {
              // Simple equality filtering
              if ((metadata as any)[key] !== value) {
                match = false;
                break;
              }
            }
            if (match) {
              processes.push(metadata);
            }
          } else {
            processes.push(metadata);
          }
        }
      }
      
      console.log(`Listed ${processes.length} processes successfully`);
      return processes;
    } catch (error) {
      console.error(`Failed to list processes: ${error}`);
      throw new Error(`Failed to list processes: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Deregister a process from the Aptos blockchain registry
   * 
   * @param processId Unique process identifier
   */
  async deregisterProcess(processId: string): Promise<void> {
    console.log(`Deregistering process ${processId} from Aptos registry`);
    
    try {
      // Call the smart contract function to deregister the process
      const transaction = await this.aptos.transaction.build.simple({
        sender: this.account.address,
        data: {
          function: `${this.moduleAddress}::${this.moduleName}::deregister_process`,
          typeArguments: [],
          functionArguments: [processId]
        }
      });
      
      const signedTx = await this.aptos.transaction.sign({
        signer: this.account,
        transaction
      });
      
      const pendingTx = await this.aptos.transaction.submit.simple({
        transaction: signedTx
      });
      
      // Wait for transaction confirmation
      await this.aptos.transaction.wait({
        transactionHash: pendingTx.hash
      });
      
      console.log(`Process ${processId} deregistered successfully`);
    } catch (error) {
      console.error(`Failed to deregister process: ${error}`);
      throw new Error(`Failed to deregister process: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
}

================
File: src/discovery/aptos/example-client.ts
================
import * as dotenv from 'dotenv';

import { ProcessMetadata } from '../interfaces';

import { AptosDiscoveryService } from './index';

// Load environment variables
dotenv.config();

/**
 * Example client for the Aptos discovery service
 */
async function main() {
  // Check for required environment variables
  const privateKey = process.env.APTOS_PRIVATE_KEY;
  const moduleAddress = process.env.APTOS_MODULE_ADDRESS;
  
  if (!privateKey) {
    console.error('Error: APTOS_PRIVATE_KEY environment variable is required');
    process.exit(1);
  }
  
  if (!moduleAddress) {
    console.error('Error: APTOS_MODULE_ADDRESS environment variable is required');
    process.exit(1);
  }
  
  // Create the discovery service
  const discoveryService = new AptosDiscoveryService({
    network: (process.env.APTOS_NETWORK || 'testnet') as any,
    nodeUrl: process.env.APTOS_NODE_URL,
    privateKey,
    moduleAddress,
    moduleName: 'process_registry'
  });
  
  console.log('Initialized Aptos discovery service');
  
  // Create a unique process ID
  const processId = `process-${Date.now()}`;
  
  // Create process metadata
  const metadata: ProcessMetadata = {
    id: processId,
    name: 'Example Process',
    description: 'A demonstration process for the Aptos blockchain',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    agents: [
      {
        id: 'agent-1',
        name: 'Main Agent',
        instructions: 'Handle the core process logic',
        goal: 'Complete the task efficiently',
        role: 'executor'
      },
      {
        id: 'agent-2',
        name: 'Helper Agent',
        instructions: 'Assist the main agent with subtasks',
        goal: 'Support the main agent',
        role: 'assistant'
      }
    ],
    workflows: [
      {
        id: 'workflow-1',
        name: 'Main Workflow',
        description: 'Core execution flow'
      }
    ],
    tags: ['example', 'aptos', 'blockchain'],
    owner: 'example-user',
    status: 'active'
  };
  
  try {
    // Register the process
    console.log(`Registering process ${processId}...`);
    await discoveryService.registerProcess(processId, metadata);
    console.log('Process registered successfully');
    
    // Retrieve the process metadata
    console.log(`Retrieving process ${processId}...`);
    const retrievedProcess = await discoveryService.getProcess(processId);
    console.log('Retrieved process:');
    console.log(JSON.stringify(retrievedProcess, null, 2));
    
    // Update the process
    console.log(`Updating process ${processId}...`);
    await discoveryService.updateProcess(processId, {
      status: 'inactive',
      updatedAt: new Date().toISOString(),
      description: 'Updated description for the demonstration process'
    });
    console.log('Process updated successfully');
    
    // Retrieve the updated process
    console.log(`Retrieving updated process ${processId}...`);
    const updatedProcess = await discoveryService.getProcess(processId);
    console.log('Updated process:');
    console.log(JSON.stringify(updatedProcess, null, 2));
    
    // List all processes
    console.log('Listing all processes...');
    const processes = await discoveryService.listProcesses();
    console.log(`Found ${processes.length} processes`);
    
    // List processes with filters
    console.log('Listing processes with "inactive" status...');
    const inactiveProcesses = await discoveryService.listProcesses({ status: 'inactive' });
    console.log(`Found ${inactiveProcesses.length} inactive processes`);
    
    // Deregister the process
    if (process.env.CLEANUP === 'true') {
      console.log(`Deregistering process ${processId}...`);
      await discoveryService.deregisterProcess(processId);
      console.log('Process deregistered successfully');
    } else {
      console.log('Skipping process deregistration (set CLEANUP=true to clean up)');
    }
    
    console.log('Example completed successfully');
  } catch (error) {
    console.error('Error during example execution:', error);
    process.exit(1);
  }
}

// Run the example if this script is executed directly
if (require.main === module) {
  main()
    .then(() => process.exit(0))
    .catch(error => {
      console.error('Example failed:', error);
      process.exit(1);
    });
}

export { main as runExample };

================
File: src/discovery/aptos/factory.ts
================
import * as dotenv from 'dotenv';

import { DiscoveryService } from '../interfaces';

import { Network } from './deploy-contract';
import { AptosDiscoveryService, AptosDiscoveryConfig } from './discovery-service';


// Try to load .env file
dotenv.config();

/**
 * Options for creating an Aptos discovery service
 */
export interface CreateAptosDiscoveryOptions {
  /**
   * Private key for Aptos account
   */
  privateKey?: string;
  
  /**
   * Network to connect to (default: 'testnet')
   */
  network?: string;
  
  /**
   * Node URL override
   */
  nodeUrl?: string;
  
  /**
   * Module address where the registry contract is deployed
   */
  moduleAddress?: string;
  
  /**
   * Name of the registry module (default: 'process_registry')
   */
  moduleName?: string;
}

/**
 * Creates an Aptos discovery service with environment or provided configuration
 * 
 * This factory function simplifies creating an Aptos discovery service by:
 * 1. Using environment variables when not explicitly provided
 * 2. Providing sensible defaults
 * 
 * Environment variables used:
 * - APTOS_PRIVATE_KEY: Private key for Aptos account
 * - APTOS_NETWORK: Network to connect to (testnet, devnet, mainnet)
 * - APTOS_NODE_URL: Node URL override
 * - APTOS_MODULE_ADDRESS: Module address where the registry contract is deployed
 * 
 * @param options Configuration options
 * @returns Configured Aptos discovery service
 */
export function createAptosDiscoveryService(options: CreateAptosDiscoveryOptions = {}): DiscoveryService {
  // Get private key from options or environment
  const privateKey = options.privateKey || process.env.APTOS_PRIVATE_KEY;
  if (!privateKey) {
    throw new Error('No private key provided. Set APTOS_PRIVATE_KEY environment variable or pass privateKey option.');
  }
  
  // Get module address from options or environment
  const moduleAddress = options.moduleAddress || process.env.APTOS_MODULE_ADDRESS;
  if (!moduleAddress) {
    throw new Error('No module address provided. Set APTOS_MODULE_ADDRESS environment variable or pass moduleAddress option.');
  }
  
  // Build configuration with defaults
  const config: AptosDiscoveryConfig = {
    privateKey,
    moduleAddress,
    network: (options.network || process.env.APTOS_NETWORK || 'testnet') as Network,
    moduleName: options.moduleName || 'process_registry'
  };
  
  // Add optional node URL if provided
  if (options.nodeUrl || process.env.APTOS_NODE_URL) {
    config.nodeUrl = options.nodeUrl || process.env.APTOS_NODE_URL;
  }
  
  // Create and return the discovery service
  return new AptosDiscoveryService(config);
}

================
File: src/discovery/aptos/index.ts
================
export { AptosDiscoveryService, AptosDiscoveryConfig } from './discovery-service';
export { deployProcessRegistry, Network } from './deploy-contract';
export { createAptosDiscoveryService, CreateAptosDiscoveryOptions } from './factory';

================
File: src/discovery/aptos/Move.toml
================
[package]
name = "ProcessRegistry"
version = "1.0.0"
authors = ["a3 Team"]

[addresses]
process_registry = "_"

[dev-addresses]
process_registry = "0x1"

[dependencies]
AptosFramework = { git = "https://github.com/aptos-labs/aptos-core.git", subdir = "aptos-move/framework/aptos-framework", rev = "mainnet" }

[dev-dependencies]

================
File: src/discovery/aptos/process_registry.move
================
module process_registry {
    use std::string::{Self, String};
    use std::vector;
    use aptos_framework::account;
    use aptos_std::table::{Self, Table};
    use aptos_framework::event::{Self, EventHandle};
    
    /// Errors
    const E_PROCESS_ALREADY_EXISTS: u64 = 1;
    const E_PROCESS_NOT_FOUND: u64 = 2;
    const E_NOT_AUTHORIZED: u64 = 3;
    
    /// ProcessRegistry stores process metadata
    struct ProcessRegistry has key {
        /// Map of process ID to process metadata
        processes: Table<String, String>,
        /// List of all process IDs
        process_ids: vector<String>,
        /// Events
        process_registered_events: EventHandle<ProcessRegisteredEvent>,
        process_updated_events: EventHandle<ProcessUpdatedEvent>,
        process_removed_events: EventHandle<ProcessRemovedEvent>,
    }
    
    /// Event emitted when a process is registered
    struct ProcessRegisteredEvent has drop, store {
        process_id: String,
        metadata: String,
    }
    
    /// Event emitted when a process is updated
    struct ProcessUpdatedEvent has drop, store {
        process_id: String,
        metadata: String,
    }
    
    /// Event emitted when a process is removed
    struct ProcessRemovedEvent has drop, store {
        process_id: String,
    }
    
    /// Initialize the process registry
    public entry fun initialize(account: &signer) {
        let addr = account::get_address(account);
        
        // Check if registry already exists
        if (exists<ProcessRegistry>(addr)) {
            return
        };
        
        // Create and initialize the registry
        move_to(account, ProcessRegistry {
            processes: table::new(),
            process_ids: vector::empty<String>(),
            process_registered_events: account::new_event_handle<ProcessRegisteredEvent>(account),
            process_updated_events: account::new_event_handle<ProcessUpdatedEvent>(account),
            process_removed_events: account::new_event_handle<ProcessRemovedEvent>(account),
        });
    }
    
    /// Register a new process
    public entry fun register_process(
        account: &signer,
        process_id: String,
        metadata: String
    ) acquires ProcessRegistry {
        let addr = account::get_address(account);
        
        // Get the registry
        let registry = borrow_global_mut<ProcessRegistry>(addr);
        
        // Ensure process doesn't already exist
        assert!(!table::contains(&registry.processes, process_id), E_PROCESS_ALREADY_EXISTS);
        
        // Add process to the registry
        table::add(&mut registry.processes, process_id, metadata);
        vector::push_back(&mut registry.process_ids, process_id);
        
        // Emit event
        event::emit_event(
            &mut registry.process_registered_events,
            ProcessRegisteredEvent { 
                process_id, 
                metadata 
            }
        );
    }
    
    /// Update an existing process
    public entry fun update_process(
        account: &signer,
        process_id: String,
        metadata: String
    ) acquires ProcessRegistry {
        let addr = account::get_address(account);
        
        // Get the registry
        let registry = borrow_global_mut<ProcessRegistry>(addr);
        
        // Ensure process exists
        assert!(table::contains(&registry.processes, process_id), E_PROCESS_NOT_FOUND);
        
        // Update the process metadata
        *table::borrow_mut(&mut registry.processes, process_id) = metadata;
        
        // Emit event
        event::emit_event(
            &mut registry.process_updated_events,
            ProcessUpdatedEvent { 
                process_id, 
                metadata 
            }
        );
    }
    
    /// Remove a process
    public entry fun deregister_process(
        account: &signer,
        process_id: String
    ) acquires ProcessRegistry {
        let addr = account::get_address(account);
        
        // Get the registry
        let registry = borrow_global_mut<ProcessRegistry>(addr);
        
        // Ensure process exists
        assert!(table::contains(&registry.processes, process_id), E_PROCESS_NOT_FOUND);
        
        // Remove the process
        table::remove(&mut registry.processes, process_id);
        
        // Remove from process_ids list
        let (found, index) = vector::index_of(&registry.process_ids, &process_id);
        if (found) {
            vector::remove(&mut registry.process_ids, index);
        };
        
        // Emit event
        event::emit_event(
            &mut registry.process_removed_events,
            ProcessRemovedEvent { 
                process_id
            }
        );
    }
    
    /// Get a process by ID (view function)
    #[view]
    public fun get_process(addr: address, process_id: String): String acquires ProcessRegistry {
        let registry = borrow_global<ProcessRegistry>(addr);
        
        assert!(table::contains(&registry.processes, process_id), E_PROCESS_NOT_FOUND);
        
        *table::borrow(&registry.processes, process_id)
    }
    
    /// List all process IDs (view function)
    #[view]
    public fun list_processes(addr: address): vector<String> acquires ProcessRegistry {
        let registry = borrow_global<ProcessRegistry>(addr);
        registry.process_ids
    }
}

================
File: src/discovery/aptos/README.md
================
# Aptos Process Registry

This module provides a blockchain-based discovery service for a3 processes using the Aptos blockchain.

## Overview

The Aptos Process Registry enables:

- Registration of process metadata on the Aptos blockchain
- Discovery of processes across different instances and environments
- Secure and decentralized process management

## Smart Contract

The `process_registry.move` file contains a Move smart contract that:

1. Stores process metadata on the blockchain
2. Provides functions to register, update, and deregister processes
3. Allows querying of process information

## Deployment

### Prerequisites

1. Install the [Aptos CLI](https://aptos.dev/cli-tools/aptos-cli-tool/install-aptos-cli)
2. Generate an Aptos account and fund it (for testnet/devnet)

### Option 1: Using the Deployment Script

The easiest way to deploy the contract is to use the included deployment script:

```bash
# Set environment variables
export APTOS_PRIVATE_KEY=your_private_key
export APTOS_NETWORK=testnet  # or devnet/mainnet

# Run the deployment script
npx ts-node src/discovery/aptos/deploy-contract.ts
```

### Option 2: Manual Deployment

1. Compile the Move module:

```bash
aptos move compile --package-dir packages/a3/src/discovery/aptos --save-metadata --named-addresses process_registry=<your-address>
```

2. Publish the module:

```bash
aptos move publish --package-dir packages/a3/src/discovery/aptos --named-addresses process_registry=<your-address>
```

3. Initialize the registry:

```bash
aptos move run --function-id <your-address>::process_registry::initialize
```

## Usage

### Using the AptosDiscoveryService

The `AptosDiscoveryService` class provides an implementation of the `DiscoveryService` interface that interacts with the deployed smart contract.

```typescript
import { AptosDiscoveryService } from '@a3/platform/discovery/aptos';

// Create an instance of the discovery service
const discoveryService = new AptosDiscoveryService({
  network: 'testnet',  // or 'devnet', 'mainnet'
  privateKey: 'your_private_key',
  moduleAddress: 'deployed_contract_address', // optional, defaults to account address
});

// Register a process
await discoveryService.registerProcess('process-123', {
  id: 'process-123',
  name: 'My Process',
  description: 'A sample process',
  createdAt: new Date().toISOString(),
  updatedAt: new Date().toISOString(),
  agents: [
    { id: 'agent-1', name: 'Worker Agent' }
  ],
  workflows: [
    { id: 'workflow-1', name: 'Main Workflow' }
  ],
  tags: ['sample', 'demo'],
  owner: 'user123',
  status: 'active'
});

// Retrieve a process
const process = await discoveryService.getProcess('process-123');
console.log(process);

// List processes
const processes = await discoveryService.listProcesses({ status: 'active' });
console.log(processes);

// Update a process
await discoveryService.updateProcess('process-123', {
  status: 'inactive',
  updatedAt: new Date().toISOString()
});

// Deregister a process
await discoveryService.deregisterProcess('process-123');
```

## Security Considerations

- The contract allows only the process owner to update or deregister processes they own
- Process data is stored as serialized JSON on the blockchain (consider data privacy)
- In production, use a secure private key management solution
- The contract uses Aptos's account-based access control model

## Testing

For local testing, it's recommended to use the Aptos local testnet:

```bash
aptos node run-local-testnet --with-faucet
```

Then deploy the contract to the local network using the deployment script:

```bash
APTOS_NETWORK=local APTOS_NODE_URL=http://localhost:8080/v1 npx ts-node src/discovery/aptos/deploy-contract.ts
```

## Resources

- [Aptos Documentation](https://aptos.dev/)
- [Move Language Documentation](https://move-language.github.io/move/)
- [Aptos TypeScript SDK](https://aptos.dev/sdks/ts-sdk/)

================
File: src/discovery/aptos/setup.ts
================
#!/usr/bin/env node
import { execSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import * as readline from 'readline';

import * as dotenv from 'dotenv';

import { deployProcessRegistry, Network } from './deploy-contract';



// Load environment variables
dotenv.config();

/**
 * Interactive setup for the Aptos Process Registry
 */
async function setup() {
  console.log('🚀 a3 Aptos Process Registry Setup');
  console.log('==================================');
  console.log('This script will help you deploy the Process Registry contract to Aptos blockchain');
  console.log('and configure your environment for using the AptosDiscoveryService.');
  console.log('\n');
  
  // Check if Aptos CLI is installed
  try {
    execSync('aptos --version', { stdio: 'pipe' });
  } catch (e) {
    console.error('❌ Aptos CLI is not installed or not in PATH');
    console.log('Please install the Aptos CLI: https://aptos.dev/cli-tools/aptos-cli-tool/install-aptos-cli');
    process.exit(1);
  }
  
  // Create interface for user input
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  
  // Promisify readline question
  const question = (query: string): Promise<string> => {
    return new Promise(resolve => {
      rl.question(query, resolve);
    });
  };
  
  try {
    // Get private key
    let privateKey = process.env.APTOS_PRIVATE_KEY;
    if (!privateKey) {
      privateKey = await question('Enter your Aptos private key (or create a new account with "aptos account create"): ');
      if (!privateKey) {
        throw new Error('Private key is required');
      }
    }
    
    // Get network
    const networkOptions = ['testnet', 'devnet', 'mainnet'];
    const defaultNetwork = process.env.APTOS_NETWORK || 'testnet';
    
    let networkInput = await question(`Choose network (${networkOptions.join('/')}) [${defaultNetwork}]: `);
    networkInput = networkInput || defaultNetwork;
    
    if (!networkOptions.includes(networkInput)) {
      throw new Error(`Invalid network: ${networkInput}. Must be one of: ${networkOptions.join(', ')}`);
    }
    
    const network = networkInput as Network;
    
    // Get node URL (optional)
    const defaultNodeUrl = getDefaultNodeUrl(network);
    const nodeUrlInput = await question(`Node URL [${defaultNodeUrl}]: `);
    const nodeUrl = nodeUrlInput || defaultNodeUrl;
    
    console.log('\n🔧 Deploying Process Registry contract...');
    
    // Deploy the contract
    const deployResult = await deployProcessRegistry({
      privateKey,
      network: network as Network,
      nodeUrl
    });
    
    const moduleAddress = deployResult.accountAddress;
    
    console.log('\n✅ Contract deployed successfully!');
    console.log(`Module address: ${moduleAddress}`);
    
    // Create .env file for the user
    const envPath = path.resolve(process.cwd(), '.env');
    const envContent = `# Aptos Process Registry Configuration
APTOS_PRIVATE_KEY=${privateKey}
APTOS_NETWORK=${network}
APTOS_NODE_URL=${nodeUrl}
APTOS_MODULE_ADDRESS=${moduleAddress}
`;
    
    const updateEnv = fs.existsSync(envPath) 
      ? await question('\nA .env file already exists. Update it with Aptos configuration? (y/n) [y]: ')
      : 'y';
    
    if (updateEnv === '' || updateEnv.toLowerCase() === 'y') {
      if (fs.existsSync(envPath)) {
        // Read existing .env and append our values, replacing any existing Aptos values
        let existingEnv = fs.readFileSync(envPath, 'utf8');
        const aptosRegex = /^APTOS_[A-Z_]+=.*/gm;
        existingEnv = existingEnv.replace(aptosRegex, '');
        
        // Remove empty lines
        existingEnv = existingEnv.replace(/\n+/g, '\n');
        
        fs.writeFileSync(envPath, existingEnv + '\n' + envContent);
      } else {
        fs.writeFileSync(envPath, envContent);
      }
      
      console.log('✅ Environment configuration saved to .env file');
    }
    
    // Create a sample implementation file
    const createExample = await question('\nCreate an example implementation file? (y/n) [y]: ');
    
    if (createExample === '' || createExample.toLowerCase() === 'y') {
      const examplePath = path.resolve(process.cwd(), 'aptos-discovery-example.ts');
      
      const exampleContent = `import { AptosDiscoveryService } from '@a3/platform/discovery/aptos';
import { ProcessMetadata } from '@a3/platform/discovery/interfaces';
import * as dotenv from 'dotenv';

// Load environment variables
dotenv.config();

async function main() {
  // Create the discovery service
  const discoveryService = new AptosDiscoveryService({
    network: process.env.APTOS_NETWORK as any,
    nodeUrl: process.env.APTOS_NODE_URL,
    privateKey: process.env.APTOS_PRIVATE_KEY!,
    moduleAddress: process.env.APTOS_MODULE_ADDRESS!,
    moduleName: 'process_registry'
  });
  
  // Create a unique process ID
  const processId = \`process-\${Date.now()}\`;
  
  // Create process metadata
  const metadata: ProcessMetadata = {
    id: processId,
    name: 'Example Process',
    description: 'A demonstration process',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    agents: [
      { id: 'agent-1', name: 'Worker Agent' }
    ],
    workflows: [
      { id: 'workflow-1', name: 'Main Workflow' }
    ],
    tags: ['example'],
    owner: 'user123',
    status: 'active'
  };
  
  // Register the process
  console.log(\`Registering process \${processId}...\`);
  await discoveryService.registerProcess(processId, metadata);
  console.log('Process registered successfully');
  
  // Retrieve the process
  const process = await discoveryService.getProcess(processId);
  console.log('Retrieved process:', process);
}

main()
  .then(() => console.log('Example completed successfully'))
  .catch(error => console.error('Error:', error));
`;
      
      fs.writeFileSync(examplePath, exampleContent);
      console.log(`✅ Example implementation saved to ${examplePath}`);
    }
    
    console.log('\n🎉 Setup completed successfully!');
    console.log('\nNext steps:');
    console.log('1. Use the AptosDiscoveryService in your code:');
    console.log('```typescript');
    console.log(`import { AptosDiscoveryService } from '@a3/platform/discovery/aptos';

const discoveryService = new AptosDiscoveryService({
  network: '${network}',
  privateKey: process.env.APTOS_PRIVATE_KEY!,
  moduleAddress: '${moduleAddress}',
  moduleName: 'process_registry'
});`);
    console.log('```');
    
    console.log('\n2. Run the example (if created):');
    console.log('```bash');
    console.log('npx ts-node aptos-discovery-example.ts');
    console.log('```');
    
    return {
      success: true,
      privateKey,
      network,
      nodeUrl,
      moduleAddress
    };
  } catch (error) {
    console.error('❌ Setup failed:', error);
    throw error;
  } finally {
    rl.close();
  }
}

/**
 * Get the default node URL for a network
 */
function getDefaultNodeUrl(network: Network | string): string {
  switch (network) {
    case Network.DEVNET:
    case 'devnet':
      return 'https://fullnode.devnet.aptoslabs.com/v1';
    case Network.MAINNET:
    case 'mainnet':
      return 'https://fullnode.mainnet.aptoslabs.com/v1';
    case Network.TESTNET:
    case 'testnet':
    default:
      return 'https://fullnode.testnet.aptoslabs.com/v1';
  }
}

// Run the setup if this script is executed directly
if (require.main === module) {
  setup()
    .then(() => process.exit(0))
    .catch(error => {
      console.error('Setup failed:', error);
      process.exit(1);
    });
}

export { setup };

================
File: src/discovery/aptos/test-contract.ts
================
import { execSync } from 'child_process';
import * as fs from 'fs';
import * as os from 'os';
import * as path from 'path';

import * as dotenv from 'dotenv';

import { ProcessMetadata } from '../interfaces';

import { deployProcessRegistry } from './deploy-contract';



// Import Network enum from deploy-contract
import { Network } from './deploy-contract';

// Load environment variables
dotenv.config();

/**
 * Test the Aptos smart contract directly using CLI commands
 */
async function testContract() {
  const privateKey = process.env.APTOS_PRIVATE_KEY;
  if (!privateKey) {
    throw new Error('APTOS_PRIVATE_KEY environment variable is required');
  }

  console.log('Starting Aptos contract test...');
  console.log('1. Deploying contract to local testnet or devnet...');
  
  // Deploy the contract
  const deployResult = await deployProcessRegistry({
    privateKey,
    network: Network.DEVNET,
    // Use devnet for testing to avoid affecting real data
  });
  
  const moduleAddress = deployResult.accountAddress;
  console.log(`Contract deployed at address: ${moduleAddress}`);

  // Create a temporary profile for testing
  const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'aptos-test-'));
  const profilePath = path.join(tempDir, '.aptos', 'config.yaml');
  
  // Ensure directory exists
  fs.mkdirSync(path.dirname(profilePath), { recursive: true });
  
  // Write profile configuration
  const profileContent = `---
profiles:
  default:
    private_key: "${privateKey}"
    public_key: "auto"
    account: "auto"
    rest_url: "https://fullnode.devnet.aptoslabs.com/v1"
    faucet_url: "https://faucet.devnet.aptoslabs.com"
`;
  
  fs.writeFileSync(profilePath, profileContent);
  
  try {
    console.log('2. Creating test process data...');
    // Create a test process
    const processId = `test-process-${Date.now()}`;
    const metadata: ProcessMetadata = {
      id: processId,
      name: 'Test Process',
      description: 'A test process for the contract',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      agents: [{ id: 'agent-1', name: 'Test Agent' }],
      workflows: [{ id: 'workflow-1', name: 'Test Workflow' }],
      tags: ['test'],
      owner: 'test-user',
      status: 'active'
    };
    
    const metadataJson = JSON.stringify(metadata);
    
    console.log('3. Registering test process...');
    // Register a process
    const registerOutput = execSync(`aptos move run --function-id ${moduleAddress}::process_registry::register_process --args string:${processId} string:'${metadataJson}'`, {
      env: { ...process.env, APTOS_CONFIG: profilePath },
      encoding: 'utf8'
    });
    
    console.log('Registration output:', registerOutput);
    
    // Wait for transaction to be processed
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    console.log('4. Fetching process data...');
    // Get process data (need to use the CLI view command)
    const getOutput = execSync(`aptos move view --function-id ${moduleAddress}::process_registry::get_process --args address:${moduleAddress} string:${processId}`, {
      env: { ...process.env, APTOS_CONFIG: profilePath },
      encoding: 'utf8'
    });
    
    console.log('Process data:', getOutput);
    
    console.log('5. Updating process...');
    // Update process
    const updatedMetadata = {
      ...metadata,
      status: 'inactive',
      description: 'Updated test description',
      updatedAt: new Date().toISOString()
    };
    
    const updateOutput = execSync(`aptos move run --function-id ${moduleAddress}::process_registry::update_process --args string:${processId} string:'${JSON.stringify(updatedMetadata)}'`, {
      env: { ...process.env, APTOS_CONFIG: profilePath },
      encoding: 'utf8'
    });
    
    console.log('Update output:', updateOutput);
    
    // Wait for transaction to be processed
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    console.log('6. Fetching all processes...');
    // List all processes
    const listOutput = execSync(`aptos move view --function-id ${moduleAddress}::process_registry::list_processes --args address:${moduleAddress}`, {
      env: { ...process.env, APTOS_CONFIG: profilePath },
      encoding: 'utf8'
    });
    
    console.log('Process list:', listOutput);
    
    console.log('7. Deregistering process...');
    // Deregister process
    const deregisterOutput = execSync(`aptos move run --function-id ${moduleAddress}::process_registry::deregister_process --args string:${processId}`, {
      env: { ...process.env, APTOS_CONFIG: profilePath },
      encoding: 'utf8'
    });
    
    console.log('Deregistration output:', deregisterOutput);
    
    console.log('✅ Contract test completed successfully!');
    return {
      success: true,
      moduleAddress
    };
  } catch (error) {
    console.error('Contract test failed:', error);
    throw error;
  } finally {
    // Clean up temporary directory
    try {
      fs.rmSync(tempDir, { recursive: true, force: true });
    } catch (e) {
      console.warn('Could not clean up temporary directory:', e);
    }
  }
}

// Run the test if this script is executed directly
if (require.main === module) {
  testContract()
    .then(result => {
      console.log('Test result:', result);
      process.exit(0);
    })
    .catch(error => {
      console.error('Test failed:', error);
      process.exit(1);
    });
}

export { testContract };

================
File: src/discovery/aptos-discovery-service.ts
================
import { AptosClient, Types, AptosAccount } from 'aptos';

import { ProcessDiscoveryService, ProcessMetadata, ProcessSearchOptions, ProcessPricing, CreatorProfile } from './process-discovery-service';

/**
 * Aptos discovery service configuration
 */
export interface AptosDiscoveryServiceConfig {
  moduleAddress: string;
  aptosClient: AptosClient;
}

/**
 * Aptos discovery service implementation
 */
export class AptosDiscoveryService implements ProcessDiscoveryService {
  private moduleAddress: string;
  private aptosClient: AptosClient;
  
  constructor(config: AptosDiscoveryServiceConfig) {
    this.moduleAddress = config.moduleAddress;
    this.aptosClient = config.aptosClient;
  }
  
  /**
   * Register a new process on the Aptos blockchain
   */
  public async registerProcess(
    account: AptosAccount | string,
    metadata: ProcessMetadata
  ): Promise<boolean> {
    try {
      // First, check if creator profile exists
      if (metadata.creatorProfile) {
        await this.ensureCreatorProfileExists(
          metadata.owner,
          metadata.creatorProfile
        );
      }
      
      // Convert string arrays to properly formatted Move vectors
      const agents = metadata.agents || [];
      const workflows = metadata.workflows || [];
      const tags = metadata.tags || [];
      
      // Register the process
      const accountObj = typeof account === 'string' ? await this.getAccount() : account;
      
      const payload: Types.TransactionPayload = {
        type: 'entry_function_payload',
        function: `${this.moduleAddress}::process_registry::register_process`,
        type_arguments: [],
        arguments: [
          metadata.id,
          metadata.name,
          metadata.description,
          agents,
          workflows,
          tags
        ]
      };
      
      const rawTx = await this.aptosClient.generateTransaction(accountObj.address().toString(), payload);
      const signedTx = await this.aptosClient.signTransaction(accountObj, rawTx);
      const response = await this.aptosClient.submitTransaction(signedTx);
      
      // Wait for transaction to complete
      await this.aptosClient.waitForTransaction(response.hash);
      
      // Set process pricing if provided
      if (metadata.pricing) {
        await this.setProcessPricing(
          metadata.id,
          metadata.pricing
        );
      }
      
      return true;
    } catch (error) {
      console.error('Error registering process:', error);
      return false;
    }
  }
  
  /**
   * Update an existing process on the Aptos blockchain
   */
  public async updateProcess(
    account: AptosAccount | string,
    processId: string,
    metadata: Partial<ProcessMetadata>
  ): Promise<boolean> {
    try {
      const accountObj = typeof account === 'string' ? await this.getAccount() : account;
      
      // Update process details
      if (metadata.name || metadata.description) {
        const payload: Types.TransactionPayload = {
          type: 'entry_function_payload',
          function: `${this.moduleAddress}::process_registry::update_process`,
          type_arguments: [],
          arguments: [
            processId,
            metadata.name || '',
            metadata.description || ''
          ]
        };
        
        const rawTx = await this.aptosClient.generateTransaction(accountObj.address().toString(), payload);
        const signedTx = await this.aptosClient.signTransaction(accountObj, rawTx);
        const response = await this.aptosClient.submitTransaction(signedTx);
        
        // Wait for transaction to complete
        await this.aptosClient.waitForTransaction(response.hash);
      }
      
      // Update agents if specified
      if (metadata.agents) {
        // Remove existing agents
        const existingProcess = await this.getProcess(processId);
        if (existingProcess) {
          for (const agent of existingProcess.agents) {
            await this.removeAgent(processId, agent);
          }
          
          // Add new agents
          for (const agent of metadata.agents) {
            await this.addAgent(processId, agent);
          }
        }
      }
      
      // Update workflows if specified
      if (metadata.workflows) {
        // Remove existing workflows
        const existingProcess = await this.getProcess(processId);
        if (existingProcess) {
          for (const workflow of existingProcess.workflows) {
            await this.removeWorkflow(processId, workflow);
          }
          
          // Add new workflows
          for (const workflow of metadata.workflows) {
            await this.addWorkflow(processId, workflow);
          }
        }
      }
      
      // Update pricing if specified
      if (metadata.pricing) {
        await this.setProcessPricing(
          processId,
          metadata.pricing
        );
      }
      
      return true;
    } catch (error) {
      console.error('Error updating process:', error);
      return false;
    }
  }
  
  /**
   * Get process details by ID
   */
  public async getProcess(processId: string): Promise<ProcessMetadata | null> {
    try {
      const payload = {
        function: `${this.moduleAddress}::process_registry::get_process`,
        type_arguments: [],
        arguments: [processId]
      };
      
      const response = await this.aptosClient.view(payload);
      
      if (response && response.length >= 10) {
        const [
          id,
          name,
          owner,
          agents,
          workflows,
          tags,
          status,
          pricingOption,
          createdAt,
          updatedAt
        ] = response;
        
        // Get creator profile if available
        let creatorProfile: CreatorProfile | undefined;
        try {
          creatorProfile = await this.getCreatorProfile(owner as string);
        } catch (error) {
          console.warn('Creator profile not found for', owner);
        }
        
        // Parse pricing information
        let pricing: ProcessPricing | undefined;
        if (pricingOption && typeof pricingOption === 'object' && 'value' in pricingOption) {
          const pricingData = pricingOption.value as {
            task_price: string;
            currency: string;
            requires_prepayment: boolean;
          };
          
          pricing = {
            taskPrice: parseInt(pricingData.task_price),
            currency: pricingData.currency,
            paymentAddress: owner as string,
            requiresPrepayment: pricingData.requires_prepayment
          };
        }
        
        const statusValues: Record<number, 'active' | 'paused' | 'deprecated'> = {
          0: 'active',
          1: 'paused',
          2: 'deprecated'
        };
        
        return {
          id: id as string,
          name: name as string,
          description: '', // Set in blockchain but not returned by the get_process function
          owner: owner as string,
          agents: (agents as string[]) || [],
          workflows: (workflows as string[]) || [],
          tags: (tags as string[]) || [],
          status: statusValues[status as number] || 'active',
          pricing,
          url: '', // This needs to be set from an off-chain registry or from metadata
          creatorProfile,
          created_at: parseInt(createdAt as string),
          updated_at: parseInt(updatedAt as string)
        };
      }
      
      return null;
    } catch (error) {
      console.error('Error getting process:', error);
      return null;
    }
  }
  
  /**
   * List processes based on search criteria
   */
  public async listProcesses(options?: ProcessSearchOptions): Promise<ProcessMetadata[]> {
    try {
      // If searching by owner, use specific function
      if (options?.owner) {
        return this.listProcessesByOwner(options.owner);
      }
      
      // If searching by tags, use specific function
      if (options?.tags && options.tags.length > 0) {
        return this.listProcessesByTag(options.tags[0]);
      }
      
      // Default to listing all processes
      const payload = {
        function: `${this.moduleAddress}::process_registry::list_all_processes`,
        type_arguments: [],
        arguments: []
      };
      
      const response = await this.aptosClient.view(payload);
      
      if (response && Array.isArray(response) && response.length > 0) {
        const processIds = response[0] as string[];
        
        // Fetch detailed information for each process
        const processes = await Promise.all(
          processIds.map(id => this.getProcess(id))
        );
        
        // Filter out null results and apply status filter if specified
        return processes
          .filter((p): p is ProcessMetadata => p !== null)
          .filter(p => !options?.status || p.status === options.status);
      }
      
      return [];
    } catch (error) {
      console.error('Error listing processes:', error);
      return [];
    }
  }
  
  /**
   * Deregister a process
   */
  public async deregisterProcess(
    account: AptosAccount | string,
    processId: string
  ): Promise<boolean> {
    try {
      const accountObj = typeof account === 'string' ? await this.getAccount() : account;
      
      const payload: Types.TransactionPayload = {
        type: 'entry_function_payload',
        function: `${this.moduleAddress}::process_registry::deregister_process`,
        type_arguments: [],
        arguments: [processId]
      };
      
      const rawTx = await this.aptosClient.generateTransaction(accountObj.address().toString(), payload);
      const signedTx = await this.aptosClient.signTransaction(accountObj, rawTx);
      const response = await this.aptosClient.submitTransaction(signedTx);
      
      // Wait for transaction to complete
      await this.aptosClient.waitForTransaction(response.hash);
      
      return true;
    } catch (error) {
      console.error('Error deregistering process:', error);
      return false;
    }
  }
  
  /**
   * List processes by owner
   */
  private async listProcessesByOwner(owner: string): Promise<ProcessMetadata[]> {
    try {
      const payload = {
        function: `${this.moduleAddress}::process_registry::list_processes_by_owner`,
        type_arguments: [],
        arguments: [owner]
      };
      
      const response = await this.aptosClient.view(payload);
      
      if (response && Array.isArray(response) && response.length > 0) {
        const processIds = response[0] as string[];
        
        // Fetch detailed information for each process
        const processes = await Promise.all(
          processIds.map(id => this.getProcess(id))
        );
        
        // Filter out null results
        return processes.filter((p): p is ProcessMetadata => p !== null);
      }
      
      return [];
    } catch (error) {
      console.error('Error listing processes by owner:', error);
      return [];
    }
  }
  
  /**
   * List processes by tag
   */
  private async listProcessesByTag(tag: string): Promise<ProcessMetadata[]> {
    try {
      const payload = {
        function: `${this.moduleAddress}::process_registry::list_processes_by_tag`,
        type_arguments: [],
        arguments: [tag]
      };
      
      const response = await this.aptosClient.view(payload);
      
      if (response && Array.isArray(response) && response.length > 0) {
        const processIds = response[0] as string[];
        
        // Fetch detailed information for each process
        const processes = await Promise.all(
          processIds.map(id => this.getProcess(id))
        );
        
        // Filter out null results
        return processes.filter((p): p is ProcessMetadata => p !== null);
      }
      
      return [];
    } catch (error) {
      console.error('Error listing processes by tag:', error);
      return [];
    }
  }
  
  /**
   * Get creator profile
   */
  private async getCreatorProfile(address: string): Promise<CreatorProfile | undefined> {
    try {
      const payload = {
        function: `${this.moduleAddress}::creator_profile::get_profile`,
        type_arguments: [],
        arguments: [address]
      };
      
      const response = await this.aptosClient.view(payload);
      
      if (response && response.length >= 5) {
        const [name, description, wallet, socialLinks, _] = response;
        
        // Parse social links if available
        const social: Record<string, string> = {};
        if (socialLinks && Array.isArray(socialLinks)) {
          for (let i = 0; i < socialLinks.length; i += 2) {
            const key = socialLinks[i];
            const value = socialLinks[i + 1];
            if (key && value) {
              social[key as string] = value as string;
            }
          }
        }
        
        return {
          name: name as string,
          description: description as string,
          walletAddress: wallet as string,
          social: Object.keys(social).length > 0 ? social : undefined
        };
      }
      
      return undefined;
    } catch (error) {
      console.error('Error getting creator profile:', error);
      return undefined;
    }
  }
  
  /**
   * Ensure creator profile exists, creating it if it doesn't
   */
  private async ensureCreatorProfileExists(
    address: string,
    profile: CreatorProfile
  ): Promise<boolean> {
    try {
      // Check if profile exists
      const exists = await this.creatorProfileExists(address);
      
      if (!exists) {
        // Create profile if it doesn't exist
        const account = await this.getAccount();
        
        // Convert social links to array format for Move
        const socialLinksArray: string[] = [];
        if (profile.social) {
          for (const [key, value] of Object.entries(profile.social)) {
            socialLinksArray.push(key);
            socialLinksArray.push(value);
          }
        }
        
        const payload: Types.TransactionPayload = {
          type: 'entry_function_payload',
          function: `${this.moduleAddress}::creator_profile::create_profile`,
          type_arguments: [],
          arguments: [
            profile.name,
            profile.description,
            address,
            socialLinksArray
          ]
        };
        
        const rawTx = await this.aptosClient.generateTransaction(account.address().toString(), payload);
        const signedTx = await this.aptosClient.signTransaction(account, rawTx);
        const response = await this.aptosClient.submitTransaction(signedTx);
        
        // Wait for transaction to complete
        await this.aptosClient.waitForTransaction(response.hash);
      }
      
      return true;
    } catch (error) {
      console.error('Error ensuring creator profile exists:', error);
      return false;
    }
  }
  
  /**
   * Check if creator profile exists
   */
  private async creatorProfileExists(address: string): Promise<boolean> {
    try {
      const payload = {
        function: `${this.moduleAddress}::creator_profile::profile_exists`,
        type_arguments: [],
        arguments: [address]
      };
      
      const response = await this.aptosClient.view(payload);
      return response[0] as boolean;
    } catch (error) {
      console.error('Error checking if creator profile exists:', error);
      return false;
    }
  }
  
  /**
   * Set process pricing
   */
  private async setProcessPricing(
    processId: string,
    pricing: ProcessPricing
  ): Promise<boolean> {
    try {
      const account = await this.getAccount();
      
      const payload: Types.TransactionPayload = {
        type: 'entry_function_payload',
        function: `${this.moduleAddress}::process_registry::set_pricing`,
        type_arguments: [],
        arguments: [
          processId,
          pricing.taskPrice.toString(),
          pricing.currency,
          pricing.requiresPrepayment
        ]
      };
      
      const rawTx = await this.aptosClient.generateTransaction(account.address().toString(), payload);
      const signedTx = await this.aptosClient.signTransaction(account, rawTx);
      const response = await this.aptosClient.submitTransaction(signedTx);
      
      // Wait for transaction to complete
      await this.aptosClient.waitForTransaction(response.hash);
      
      return true;
    } catch (error) {
      console.error('Error setting process pricing:', error);
      return false;
    }
  }
  
  /**
   * Add agent to process
   */
  private async addAgent(
    processId: string,
    agentAddress: string
  ): Promise<boolean> {
    try {
      const account = await this.getAccount();
      
      const payload: Types.TransactionPayload = {
        type: 'entry_function_payload',
        function: `${this.moduleAddress}::process_registry::add_agent`,
        type_arguments: [],
        arguments: [
          processId,
          agentAddress
        ]
      };
      
      const rawTx = await this.aptosClient.generateTransaction(account.address().toString(), payload);
      const signedTx = await this.aptosClient.signTransaction(account, rawTx);
      const response = await this.aptosClient.submitTransaction(signedTx);
      
      // Wait for transaction to complete
      await this.aptosClient.waitForTransaction(response.hash);
      
      return true;
    } catch (error) {
      console.error('Error adding agent to process:', error);
      return false;
    }
  }
  
  /**
   * Remove agent from process
   */
  private async removeAgent(
    processId: string,
    agentAddress: string
  ): Promise<boolean> {
    try {
      const account = await this.getAccount();
      
      const payload: Types.TransactionPayload = {
        type: 'entry_function_payload',
        function: `${this.moduleAddress}::process_registry::remove_agent`,
        type_arguments: [],
        arguments: [
          processId,
          agentAddress
        ]
      };
      
      const rawTx = await this.aptosClient.generateTransaction(account.address().toString(), payload);
      const signedTx = await this.aptosClient.signTransaction(account, rawTx);
      const response = await this.aptosClient.submitTransaction(signedTx);
      
      // Wait for transaction to complete
      await this.aptosClient.waitForTransaction(response.hash);
      
      return true;
    } catch (error) {
      console.error('Error removing agent from process:', error);
      return false;
    }
  }
  
  /**
   * Add workflow to process
   */
  private async addWorkflow(
    processId: string,
    workflowId: string
  ): Promise<boolean> {
    try {
      const account = await this.getAccount();
      
      const payload: Types.TransactionPayload = {
        type: 'entry_function_payload',
        function: `${this.moduleAddress}::process_registry::add_workflow`,
        type_arguments: [],
        arguments: [
          processId,
          workflowId
        ]
      };
      
      const rawTx = await this.aptosClient.generateTransaction(account.address().toString(), payload);
      const signedTx = await this.aptosClient.signTransaction(account, rawTx);
      const response = await this.aptosClient.submitTransaction(signedTx);
      
      // Wait for transaction to complete
      await this.aptosClient.waitForTransaction(response.hash);
      
      return true;
    } catch (error) {
      console.error('Error adding workflow to process:', error);
      return false;
    }
  }
  
  /**
   * Remove workflow from process
   */
  private async removeWorkflow(
    processId: string,
    workflowId: string
  ): Promise<boolean> {
    try {
      const account = await this.getAccount();
      
      const payload: Types.TransactionPayload = {
        type: 'entry_function_payload',
        function: `${this.moduleAddress}::process_registry::remove_workflow`,
        type_arguments: [],
        arguments: [
          processId,
          workflowId
        ]
      };
      
      const rawTx = await this.aptosClient.generateTransaction(account.address().toString(), payload);
      const signedTx = await this.aptosClient.signTransaction(account, rawTx);
      const response = await this.aptosClient.submitTransaction(signedTx);
      
      // Wait for transaction to complete
      await this.aptosClient.waitForTransaction(response.hash);
      
      return true;
    } catch (error) {
      console.error('Error removing workflow from process:', error);
      return false;
    }
  }
  
  /**
   * Get account for transactions
   * 
   * This is a placeholder for getting the account from environment or config
   * In a real implementation, this would be injected or provided securely
   */
  private async getAccount(): Promise<AptosAccount> {
    // This is a placeholder - in a real implementation, you would get the account
    // from a secure source or have it injected
    throw new Error('getAccount not implemented. You need to provide an account for transactions.');
  }
}

================
File: src/discovery/index.ts
================
/**
 * Discovery Module
 * 
 * Provides services for registering and discovering processes across environments.
 */

export * from './interfaces';
export * from './aptos';

// Add a factory function to create the discovery service
import { createAptosDiscoveryService as createAptosService } from './aptos/factory';
import { DiscoveryService, ProcessMetadata } from './interfaces';

/**
 * Create a no-operation discovery service for testing or environments
 * where discovery is not needed
 */
export function createNoopDiscoveryService(): DiscoveryService {
  return {
    async registerProcess(processId: string, metadata: ProcessMetadata): Promise<void> {
      console.log('Noop register process called', { processId });
    },
    
    async updateProcess(processId: string, metadata: Partial<ProcessMetadata>): Promise<void> {
      console.log('Noop update process called', { processId });
    },
    
    async getProcess(processId: string): Promise<ProcessMetadata | null> {
      console.log('Noop get process called', { processId });
      return null;
    },
    
    async listProcesses(filters?: Record<string, any>): Promise<ProcessMetadata[]> {
      console.log('Noop list processes called', { filters });
      return [];
    },
    
    async deregisterProcess(processId: string): Promise<void> {
      console.log('Noop deregister process called', { processId });
    }
  };
}

/**
 * Create an Aptos-based discovery service
 * 
 * This function is a re-export of the factory function from aptos/factory.ts.
 * It simplifies configuration by supporting environment variables when options are not provided.
 * 
 * @param options Configuration options for the Aptos discovery service
 */
export const createAptosDiscoveryService = createAptosService;

================
File: src/discovery/interfaces.ts
================
import { CreatorProfile } from '../creator/interfaces';
import { ProcessPricing } from '../payment/interfaces';

/**
 * Process metadata that will be stored in the discovery service
 */
export interface ProcessMetadata {
  id: string;
  name?: string;
  description?: string;
  createdAt: string;
  updatedAt: string;
  agents: Array<{
    id: string;
    name?: string;
    instructions?: string;
    goal?: string;
    role?: string;
  }>;
  workflows: Array<{
    id: string;
    name?: string;
    description?: string;
  }>;
  tags?: string[];
  owner: string;
  status: 'active' | 'inactive' | 'error';
  creatorProfile?: CreatorProfile;
  pricing?: ProcessPricing;
}

/**
 * Base discovery service interface
 */
export interface DiscoveryService {
  /**
   * Register a process with the discovery service
   * 
   * @param processId Unique process identifier
   * @param metadata Process metadata
   */
  registerProcess(processId: string, metadata: ProcessMetadata): Promise<void>;
  
  /**
   * Update process metadata in the discovery service
   * 
   * @param processId Unique process identifier
   * @param metadata Updated process metadata
   */
  updateProcess(processId: string, metadata: Partial<ProcessMetadata>): Promise<void>;
  
  /**
   * Retrieve process metadata from the discovery service
   * 
   * @param processId Unique process identifier
   */
  getProcess(processId: string): Promise<ProcessMetadata | null>;
  
  /**
   * List processes matching the specified filters
   * 
   * @param filters Optional filters to apply
   */
  listProcesses(filters?: Record<string, any>): Promise<ProcessMetadata[]>;
  
  /**
   * Deregister a process from the discovery service
   * 
   * @param processId Unique process identifier
   */
  deregisterProcess(processId: string): Promise<void>;
}

================
File: src/discovery/process-discovery-service.ts
================
import { AptosAccount } from 'aptos';

/**
 * Process metadata interface
 */
export interface ProcessMetadata {
  id: string;
  name: string;
  description: string;
  owner: string;
  agents: string[];
  workflows: string[];
  tags: string[];
  status: 'active' | 'paused' | 'deprecated';
  pricing?: ProcessPricing;
  url: string;
  creatorProfile?: CreatorProfile;
  created_at: number;
  updated_at: number;
}

/**
 * Process pricing interface
 */
export interface ProcessPricing {
  taskPrice: number;
  currency: string;
  paymentAddress: string;
  requiresPrepayment: boolean;
}

/**
 * Creator profile interface
 */
export interface CreatorProfile {
  name: string;
  description: string;
  walletAddress: string;
  social?: Record<string, string>;
}

/**
 * Process search options
 */
export interface ProcessSearchOptions {
  owner?: string;
  tags?: string[];
  status?: 'active' | 'paused' | 'deprecated';
}

/**
 * Process discovery service interface
 */
export interface ProcessDiscoveryService {
  /**
   * Register a new process
   * 
   * @param account Account used for transaction
   * @param metadata Process metadata
   * @returns Promise resolving to success status
   */
  registerProcess(account: AptosAccount | string, metadata: ProcessMetadata): Promise<boolean>;
  
  /**
   * Update an existing process
   * 
   * @param account Account used for transaction
   * @param processId Process ID
   * @param metadata Updated process metadata
   * @returns Promise resolving to success status
   */
  updateProcess(account: AptosAccount | string, processId: string, metadata: Partial<ProcessMetadata>): Promise<boolean>;
  
  /**
   * Get process details by ID
   * 
   * @param processId Process ID
   * @returns Promise resolving to process metadata or null if not found
   */
  getProcess(processId: string): Promise<ProcessMetadata | null>;
  
  /**
   * List processes based on search criteria
   * 
   * @param options Search options
   * @returns Promise resolving to array of matching processes
   */
  listProcesses(options?: ProcessSearchOptions): Promise<ProcessMetadata[]>;
  
  /**
   * Deregister a process
   * 
   * @param account Account used for transaction
   * @param processId Process ID
   * @returns Promise resolving to success status
   */
  deregisterProcess(account: AptosAccount | string, processId: string): Promise<boolean>;
}

================
File: src/payment/aptos-payment-service.ts
================
import { AptosClient, Types, AptosAccount } from 'aptos';

import {
  PaymentService,
  PaymentVerificationResult,
  PaymentDetails,
  PaymentRequest,
  PaymentReleaseRequest,
  RefundRequest,
  ProcessPricing,
  PaymentStatus
} from './interfaces';

/**
 * Configuration for Aptos payment service
 */
interface AptosPaymentServiceConfig {
  moduleAddress: string;
  aptosClient: AptosClient;
}

/**
 * Aptos payment service implementation
 */
export class AptosPaymentService implements PaymentService {
  private moduleAddress: string;
  private aptosClient: AptosClient;
  
  /**
   * Create a new Aptos payment service
   * 
   * @param config Service configuration
   */
  constructor(config: AptosPaymentServiceConfig) {
    this.moduleAddress = config.moduleAddress;
    this.aptosClient = config.aptosClient;
  }
  
  /**
   * Make a payment for a process
   * 
   * @param account Account making the payment
   * @param request Payment request
   * @returns Promise resolving to transaction hash
   */
  public async makePayment(
    account: AptosAccount,
    request: PaymentRequest
  ): Promise<string> {
    const payload: Types.TransactionPayload = {
      type: 'entry_function_payload',
      function: `${this.moduleAddress}::payment::make_payment`,
      type_arguments: [],
      arguments: [
        request.processId,
        request.taskId,
        request.amount
      ]
    };
    
    const rawTx = await this.aptosClient.generateTransaction(account.address().toString(), payload);
    const signedTx = await this.aptosClient.signTransaction(account, rawTx);
    const response = await this.aptosClient.submitTransaction(signedTx);
    
    // Wait for transaction to complete
    await this.aptosClient.waitForTransaction(response.hash);
    
    return response.hash;
  }
  
  /**
   * Verify payment for a process
   * 
   * @param userAddress User's wallet address
   * @param processId Process ID
   * @param taskId Task ID
   * @returns Promise resolving to verification result
   */
  public async verifyPayment(
    userAddress: string,
    processId: string,
    taskId: string
  ): Promise<PaymentVerificationResult> {
    try {
      const payload = {
        function: `${this.moduleAddress}::payment::verify_payment`,
        type_arguments: [],
        arguments: [processId, taskId, userAddress]
      };
      
      const response = await this.aptosClient.view(payload);
      const verified = response[0] as boolean;
      
      if (!verified) {
        return {
          verified: false,
          error: 'Payment not found or insufficient'
        };
      }
      
      // Get payment details
      const details = await this.getPaymentDetails(userAddress, processId, taskId);
      
      if (!details) {
        return {
          verified: true,
          status: 'escrow',
          error: 'Payment verified but details not found'
        };
      }
      
      // Map status from number to string
      let status: 'escrow' | 'completed' | 'refunded';
      
      switch (details.status) {
        case PaymentStatus.ESCROW:
          status = 'escrow';
          break;
        case PaymentStatus.COMPLETED:
          status = 'completed';
          break;
        case PaymentStatus.REFUNDED:
          status = 'refunded';
          break;
        default:
          status = 'escrow';
      }
      
      return {
        verified: true,
        status,
        amount: details.amount,
        timestamp: details.paymentTime
      };
    } catch (error) {
      console.error('Error verifying payment:', error);
      return {
        verified: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  
  /**
   * Get payment details
   * 
   * @param userAddress User's wallet address
   * @param processId Process ID
   * @param taskId Task ID
   * @returns Promise resolving to payment details or null if not found
   */
  public async getPaymentDetails(
    userAddress: string,
    processId: string,
    taskId: string
  ): Promise<PaymentDetails | null> {
    try {
      const payload = {
        function: `${this.moduleAddress}::payment::get_payment`,
        type_arguments: [],
        arguments: [processId, taskId, userAddress]
      };
      
      const response = await this.aptosClient.view(payload);
      
      return {
        processId: response[0] as string,
        taskId: response[1] as string,
        payer: response[2] as string,
        receiver: response[3] as string,
        amount: response[4].toString(),
        currency: response[5] as string,
        status: Number(response[6]) as PaymentStatus,
        paymentTime: Number(response[7]),
        expirationTime: Number(response[8])
      };
    } catch (error) {
      console.error('Error getting payment details:', error);
      return null;
    }
  }
  
  /**
   * Release payment from escrow after task completion approval
   * 
   * @param account Account requesting release (must be payer/requester)
   * @param request Release request
   * @returns Promise resolving to transaction hash
   */
  public async releasePayment(
    account: AptosAccount,
    request: PaymentReleaseRequest
  ): Promise<string> {
    const payload: Types.TransactionPayload = {
      type: 'entry_function_payload',
      function: `${this.moduleAddress}::payment::release_payment`,
      type_arguments: [],
      arguments: [
        request.processId,
        request.taskId
      ]
    };
    
    const rawTx = await this.aptosClient.generateTransaction(account.address().toString(), payload);
    const signedTx = await this.aptosClient.signTransaction(account, rawTx);
    const response = await this.aptosClient.submitTransaction(signedTx);
    
    // Wait for transaction to complete
    await this.aptosClient.waitForTransaction(response.hash);
    
    return response.hash;
  }
  
  /**
   * Request a refund for a payment
   * 
   * @param account Account requesting the refund
   * @param request Refund request
   * @returns Promise resolving to transaction hash
   */
  public async requestRefund(
    account: AptosAccount,
    request: RefundRequest
  ): Promise<string> {
    const payload: Types.TransactionPayload = {
      type: 'entry_function_payload',
      function: `${this.moduleAddress}::payment::request_refund`,
      type_arguments: [],
      arguments: [
        request.processId,
        request.taskId
      ]
    };
    
    const rawTx = await this.aptosClient.generateTransaction(account.address().toString(), payload);
    const signedTx = await this.aptosClient.signTransaction(account, rawTx);
    const response = await this.aptosClient.submitTransaction(signedTx);
    
    // Wait for transaction to complete
    await this.aptosClient.waitForTransaction(response.hash);
    
    return response.hash;
  }
  
  /**
   * Get payment instructions for a process
   * 
   * @param pricing Process pricing information
   * @param userAddress User's wallet address
   * @returns Payment instructions as a string
   */
  public getPaymentInstructions(
    pricing: ProcessPricing,
    userAddress: string
  ): string {
    if (!pricing.requiresPrepayment) {
      return 'This process does not require prepayment.';
    }
    
    if (!pricing.paymentAddress) {
      return 'Payment address not specified. Please contact the process owner.';
    }
    
    const networkName = this.aptosClient.nodeUrl.includes('mainnet') ? 'mainnet' : 'testnet';
    const explorerBaseUrl = networkName === 'mainnet' 
      ? 'https://explorer.aptoslabs.com' 
      : 'https://explorer.aptoslabs.com/testnet';
      
    const currency = pricing.currency || 'APT';
    
    return `
To run this process, please make a payment of ${pricing.taskPrice} ${currency}.

Payment will be held in escrow until the task is completed and approved.

You can make the payment through:

1. CLI: 
   aptos move run --function ${this.moduleAddress}::payment::make_payment \\
   --args string:${pricing.paymentAddress} string:${pricing.taskPrice} \\
   --account ${userAddress}
   
2. SDK:
   Use the SDK's makePayment function with your account and the process ID.
   
3. Explorer:
   Visit ${explorerBaseUrl} and connect your wallet to make the transaction.
   
After payment, your funds will be held securely in escrow and only released when you approve the completed task.
`;
  }
}

================
File: src/payment/interfaces.ts
================
/**
 * Payment Service Interfaces
 */

import { AptosAccount } from 'aptos';

/**
 * Process pricing information
 */
export interface ProcessPricing {
  /** Price per task execution */
  taskPrice: string;
  
  /** Currency code (defaults to APT for Aptos) */
  currency?: string;
  
  /** Address where payments should be sent */
  paymentAddress?: string;
  
  /** Whether payment is required before process execution */
  requiresPrepayment?: boolean;
}

/**
 * Payment verification result
 */
export interface PaymentVerificationResult {
  /** Whether the payment verification was successful */
  verified: boolean;
  
  /** Payment status if verified (escrow, completed, refunded) */
  status?: 'escrow' | 'completed' | 'refunded';
  
  /** Optional transaction hash of the payment */
  transactionHash?: string;
  
  /** Optional error message if verification failed */
  error?: string;
  
  /** Optional timestamp of when the payment was made */
  timestamp?: string | number;
  
  /** Optional amount of the payment */
  amount?: string;
}

/**
 * Payment status enum
 */
export enum PaymentStatus {
  ESCROW = 1,
  COMPLETED = 2,
  REFUNDED = 3
}

/**
 * Payment details
 */
export interface PaymentDetails {
  processId: string;
  taskId: string;
  payer: string;
  receiver: string;
  amount: string;
  currency: string;
  status: PaymentStatus;
  paymentTime: number;
  expirationTime: number;
  txHash?: string;
}

/**
 * Payment request
 */
export interface PaymentRequest {
  processId: string;
  taskId: string;
  amount: string;
  currency?: string;
}

/**
 * Payment release request
 */
export interface PaymentReleaseRequest {
  processId: string;
  taskId: string;
}

/**
 * Refund request
 */
export interface RefundRequest {
  processId: string;
  taskId: string;
}

/**
 * Service for handling payments between agents
 */
export interface PaymentService {
  /**
   * Make a payment for a process (holds in escrow)
   * 
   * @param account Account making the payment
   * @param request Payment request details
   * @returns Promise resolving to transaction hash
   */
  makePayment(
    account: AptosAccount,
    request: PaymentRequest
  ): Promise<string>;
  
  /**
   * Verify if a payment has been made for a process
   * 
   * @param userAddress User's wallet address
   * @param processId Process ID
   * @param taskId Task ID
   * @returns Promise resolving to verification result
   */
  verifyPayment(
    userAddress: string,
    processId: string,
    taskId: string
  ): Promise<PaymentVerificationResult>;
  
  /**
   * Get payment details for a process
   * 
   * @param userAddress User's wallet address
   * @param processId Process ID
   * @param taskId Task ID
   * @returns Promise resolving to payment details or null if not found
   */
  getPaymentDetails(
    userAddress: string,
    processId: string,
    taskId: string
  ): Promise<PaymentDetails | null>;
  
  /**
   * Release payment from escrow after task completion approval
   * 
   * @param account Account requesting release (must be payer/requester)
   * @param request Release request details
   * @returns Promise resolving to transaction hash
   */
  releasePayment(
    account: AptosAccount,
    request: PaymentReleaseRequest
  ): Promise<string>;
  
  /**
   * Request a refund for a payment
   * 
   * @param account Account requesting the refund
   * @param request Refund request details
   * @returns Promise resolving to transaction hash
   */
  requestRefund(
    account: AptosAccount,
    request: RefundRequest
  ): Promise<string>;
  
  /**
   * Get payment instructions for a process
   * 
   * @param pricing Process pricing information
   * @param userAddress User's wallet address
   * @returns Payment instructions as a string
   */
  getPaymentInstructions(
    pricing: ProcessPricing,
    userAddress: string
  ): string;
}

================
File: src/payment/payment-service.ts
================
import { AptosClient, Types, AptosAccount } from 'aptos';

/**
 * Payment details
 */
export interface PaymentDetails {
  processId: string;
  payer: string;
  receiver: string;
  amount: number;
  currency: string;
  status: 'pending' | 'completed' | 'refunded';
  paymentTime: number;
  expirationTime: number;
}

/**
 * Payment request data
 */
export interface PaymentRequest {
  processId: string;
  amount: number;
}

/**
 * Payment service configuration
 */
export interface PaymentServiceConfig {
  moduleAddress: string;
  aptosClient: AptosClient;
}

/**
 * Payment service interface
 */
export interface PaymentService {
  /**
   * Make a payment for a process
   * 
   * @param account Account making the payment
   * @param request Payment request data
   * @returns Promise resolving to transaction hash
   */
  makePayment(
    account: AptosAccount,
    request: PaymentRequest
  ): Promise<string>;
  
  /**
   * Verify if a payment has been made for a process
   * 
   * @param processId Process ID
   * @param payerAddress Payer wallet address
   * @returns Promise resolving to verification status
   */
  verifyPayment(
    processId: string,
    payerAddress: string
  ): Promise<boolean>;
  
  /**
   * Get payment details
   * 
   * @param processId Process ID
   * @param payerAddress Payer wallet address
   * @returns Promise resolving to payment details or null if not found
   */
  getPaymentDetails(
    processId: string,
    payerAddress: string
  ): Promise<PaymentDetails | null>;
  
  /**
   * Request a refund for a payment
   * 
   * @param account Account requesting the refund
   * @param processId Process ID
   * @returns Promise resolving to transaction hash
   */
  requestRefund(
    account: AptosAccount,
    processId: string
  ): Promise<string>;
}

/**
 * Aptos payment service implementation
 */
export class AptosPaymentService implements PaymentService {
  private moduleAddress: string;
  private aptosClient: AptosClient;
  
  constructor(config: PaymentServiceConfig) {
    this.moduleAddress = config.moduleAddress;
    this.aptosClient = config.aptosClient;
  }
  
  /**
   * Make a payment for a process
   */
  public async makePayment(
    account: AptosAccount,
    request: PaymentRequest
  ): Promise<string> {
    const payload: Types.TransactionPayload = {
      type: 'entry_function_payload',
      function: `${this.moduleAddress}::payment::make_payment`,
      type_arguments: [],
      arguments: [
        request.processId,
        request.amount.toString()
      ]
    };
    
    const rawTx = await this.aptosClient.generateTransaction(account.address().toString(), payload);
    const signedTx = await this.aptosClient.signTransaction(account, rawTx);
    const response = await this.aptosClient.submitTransaction(signedTx);
    
    // Wait for transaction to complete
    await this.aptosClient.waitForTransaction(response.hash);
    
    return response.hash;
  }
  
  /**
   * Verify if a payment has been made for a process
   */
  public async verifyPayment(
    processId: string,
    payerAddress: string
  ): Promise<boolean> {
    try {
      const payload = {
        function: `${this.moduleAddress}::payment::verify_payment`,
        type_arguments: [],
        arguments: [processId, payerAddress]
      };
      
      const response = await this.aptosClient.view(payload);
      return response[0] as boolean;
    } catch (error) {
      console.error('Error verifying payment:', error);
      return false;
    }
  }
  
  /**
   * Get payment details
   */
  public async getPaymentDetails(
    processId: string,
    payerAddress: string
  ): Promise<PaymentDetails | null> {
    try {
      const payload = {
        function: `${this.moduleAddress}::payment::get_payment`,
        type_arguments: [],
        arguments: [processId, payerAddress]
      };
      
      const response = await this.aptosClient.view(payload);
      
      // Process response data
      if (response && response.length >= 8) {
        return {
          processId: response[0] as string,
          payer: response[1] as string,
          receiver: response[2] as string,
          amount: parseInt(response[3] as string),
          currency: response[4] as string,
          // Map numeric status to string
          status: ['pending', 'completed', 'refunded'][parseInt(response[5] as string)] as 'pending' | 'completed' | 'refunded',
          paymentTime: parseInt(response[6] as string),
          expirationTime: parseInt(response[7] as string)
        };
      }
      
      return null;
    } catch (error) {
      console.error('Error getting payment details:', error);
      return null;
    }
  }
  
  /**
   * Request a refund for a payment
   */
  public async requestRefund(
    account: AptosAccount,
    processId: string
  ): Promise<string> {
    const payload: Types.TransactionPayload = {
      type: 'entry_function_payload',
      function: `${this.moduleAddress}::payment::request_refund`,
      type_arguments: [],
      arguments: [processId]
    };
    
    const rawTx = await this.aptosClient.generateTransaction(account.address().toString(), payload);
    const signedTx = await this.aptosClient.signTransaction(account, rawTx);
    const response = await this.aptosClient.submitTransaction(signedTx);
    
    // Wait for transaction to complete
    await this.aptosClient.waitForTransaction(response.hash);
    
    return response.hash;
  }
}

================
File: src/process/extended-process.ts
================
import { v4 as uuidv4 } from 'uuid';

import { CreatorProfile } from '../creator/interfaces';
import { DiscoveryService, ProcessMetadata } from '../discovery/interfaces';
import { PaymentService, ProcessPricing } from '../payment/interfaces';


// Basic placeholder for ProcessConfig
export interface ProcessConfig {
  [key: string]: any;
}

// Events enum
export enum ProcessEvent {
  AGENT_CREATED = 'agent:created',
  AGENT_DELETED = 'agent:deleted',
  WORKFLOW_CREATED = 'workflow:created',
  WORKFLOW_DELETED = 'workflow:deleted'
}

// Process class mock/placeholder - to be replaced with actual import from @a2/core
export class Process {
  private eventHandlers: Record<string, Array<(data?: unknown) => void>> = {};
  protected logger: Console = console;
  private agents: Record<string, any> = {};
  private workflow: any = null;
  
  constructor(_config?: ProcessConfig) {
    // Basic initialization
  }
  
  on(eventName: string, handler: (data?: unknown) => void): void {
    if (!this.eventHandlers[eventName]) {
      this.eventHandlers[eventName] = [];
    }
    this.eventHandlers[eventName].push(handler);
  }
  
  protected emit(eventName: string, data?: unknown): void {
    const handlers = this.eventHandlers[eventName] || [];
    for (const handler of handlers) {
      handler(data);
    }
  }
  
  getLogger(): Console {
    return this.logger;
  }
  
  getAgents(): Record<string, any> {
    return this.agents;
  }
  
  getWorkflow(): any {
    return this.workflow;
  }
  
  async initialize(): Promise<void> {
    console.log('Base process initialized');
  }
}

/**
 * Extended process configuration that includes discovery service
 */
export interface ExtendedProcessConfig extends ProcessConfig {
  /**
   * Discovery service for process registration
   */
  discoveryService?: DiscoveryService;
  
  /**
   * Payment service for handling payments
   */
  paymentService?: PaymentService;
  
  /**
   * Process metadata for discovery
   */
  metadata?: {
    name?: string;
    description?: string;
    tags?: string[];
    owner?: string;
    creatorProfile?: CreatorProfile;
    pricing?: {
      taskPrice: string; // price in tokens as string to avoid precision issues
      currency?: string; // default is blockchain native token
      paymentAddress?: string; // wallet to receive payments
      requiresPrepayment?: boolean; // whether payment is required before process execution
    };
  };
}

/**
 * Extended Process class with discovery and payment capabilities
 * 
 * This class extends the core Process class with the ability to
 * register itself with a discovery service and handle payments.
 */
export class ExtendedProcess extends Process {
  private discoveryService?: DiscoveryService;
  private paymentService?: PaymentService;
  private processId: string;
  private metadata: Partial<ProcessMetadata>;
  private registered = false;
  
  /**
   * Creates a new Extended Process instance
   * 
   * @param config Optional configuration object
   */
  constructor(config?: ExtendedProcessConfig) {
    super(config);
    
    // Generate a unique ID for this process
    this.processId = uuidv4();
    
    // Initialize services if provided
    this.discoveryService = config?.discoveryService;
    this.paymentService = config?.paymentService;
    
    // Initialize metadata
    this.metadata = {
      name: config?.metadata?.name || `Process-${this.processId.substring(0, 8)}`,
      description: config?.metadata?.description,
      tags: config?.metadata?.tags || [],
      owner: config?.metadata?.owner || 'anonymous',
      creatorProfile: config?.metadata?.creatorProfile,
      pricing: config?.metadata?.pricing ? {
        taskPrice: config.metadata.pricing.taskPrice,
        currency: config.metadata.pricing.currency || 'APT',
        paymentAddress: config.metadata.pricing.paymentAddress,
        requiresPrepayment: config.metadata.pricing.requiresPrepayment ?? true
      } : undefined
    };
    
    // Register with discovery when agents or workflows are created
    this.on(ProcessEvent.AGENT_CREATED, this.handleAgentCreated.bind(this));
    this.on(ProcessEvent.WORKFLOW_CREATED, this.handleWorkflowCreated.bind(this));
    this.on(ProcessEvent.AGENT_DELETED, this.handleAgentDeleted.bind(this));
    this.on(ProcessEvent.WORKFLOW_DELETED, this.handleWorkflowDeleted.bind(this));
    
    // Log initialization
    this.getLogger().info('Initializing Extended Process with discovery capabilities', {
      processId: this.processId,
      discoveryEnabled: !!this.discoveryService,
      paymentEnabled: !!this.paymentService
    });
  }
  
  /**
   * Initializes the process and registers with discovery service
   */
  async initialize(): Promise<void> {
    // Initialize the base process
    await super.initialize();
    
    // Register with discovery service if available
    if (this.discoveryService) {
      await this.registerWithDiscovery();
    }
  }
  
  /**
   * Gets the unique process ID
   */
  getProcessId(): string {
    return this.processId;
  }
  
  /**
   * Sets the discovery service
   * 
   * @param service Discovery service instance
   */
  setDiscoveryService(service: DiscoveryService): void {
    this.discoveryService = service;
    this.getLogger().info('Discovery service set', { processId: this.processId });
    
    // Register with discovery if not already registered
    if (!this.registered && this.discoveryService) {
      this.registerWithDiscovery().catch(error => {
        this.getLogger().error('Failed to register with discovery service', { error });
      });
    }
  }
  
  /**
   * Gets the discovery service
   */
  getDiscoveryService(): DiscoveryService | undefined {
    return this.discoveryService;
  }
  
  /**
   * Updates metadata for the process
   * 
   * @param metadata Updated metadata
   */
  async updateMetadata(metadata: Partial<ProcessMetadata>): Promise<void> {
    // Update local metadata
    this.metadata = { ...this.metadata, ...metadata };
    
    // Update in discovery service if registered
    if (this.registered && this.discoveryService) {
      try {
        await this.discoveryService.updateProcess(this.processId, metadata);
        this.getLogger().info('Process metadata updated in discovery service', { 
          processId: this.processId 
        });
      } catch (error) {
        this.getLogger().error('Failed to update process metadata in discovery service', { 
          processId: this.processId, 
          error 
        });
        throw error;
      }
    }
  }
  
  /**
   * Registers the process with the discovery service
   * @private
   */
  private async registerWithDiscovery(): Promise<void> {
    if (!this.discoveryService) {
      return;
    }
    
    try {
      // Build full process metadata
      const metadata: ProcessMetadata = {
        id: this.processId,
        name: this.metadata.name as string,
        description: this.metadata.description,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        agents: this.buildAgentsMetadata(),
        workflows: this.buildWorkflowsMetadata(),
        tags: this.metadata.tags,
        owner: this.metadata.owner as string,
        status: 'active'
      };
      
      // Register with discovery service
      await this.discoveryService.registerProcess(this.processId, metadata);
      this.registered = true;
      
      this.getLogger().info('Process registered with discovery service', { 
        processId: this.processId 
      });
    } catch (error) {
      this.getLogger().error('Failed to register process with discovery service', { 
        processId: this.processId, 
        error 
      });
      throw error;
    }
  }
  
  /**
   * Updates the process registration with the discovery service
   * @private
   */
  private async updateDiscoveryRegistration(): Promise<void> {
    if (!this.discoveryService || !this.registered) {
      return;
    }
    
    try {
      // Update just the agents and workflows
      const updateData: Partial<ProcessMetadata> = {
        updatedAt: new Date().toISOString(),
        agents: this.buildAgentsMetadata(),
        workflows: this.buildWorkflowsMetadata()
      };
      
      // Update discovery service
      await this.discoveryService.updateProcess(this.processId, updateData);
      
      this.getLogger().info('Process registration updated in discovery service', { 
        processId: this.processId 
      });
    } catch (error) {
      this.getLogger().error('Failed to update process registration in discovery service', { 
        processId: this.processId, 
        error 
      });
      // Don't throw, just log the error
    }
  }
  
  /**
   * Builds metadata about the current agents
   * @private
   */
  private buildAgentsMetadata(): Array<{
    id: string;
    name?: string;
    instructions?: string;
    goal?: string;
    role?: string;
  }> {
    const agents = this.getAgents();
    return Object.entries(agents).map(([id, _agent]) => {
      // In a real implementation, we would get metadata from the agent
      return {
        id,
        name: id, // Using id as name for placeholder
        instructions: 'placeholder',
        goal: 'placeholder',
        role: 'placeholder'
      };
    });
  }
  
  /**
   * Builds metadata about the current workflows
   * @private
   */
  private buildWorkflowsMetadata(): Array<{
    id: string;
    name?: string;
    description?: string;
  }> {
    const workflow = this.getWorkflow();
    if (!workflow) {
      return [];
    }
    
    // In a real implementation, we would get metadata from the workflow
    return [{
      id: 'workflow-1',
      name: 'Workflow 1',
      description: 'Placeholder workflow'
    }];
  }
  
  /**
   * Handles agent created event
   * @private
   */
  private handleAgentCreated(): void {
    this.updateDiscoveryRegistration().catch(error => {
      this.getLogger().error('Failed to update discovery after agent creation', { error });
    });
  }
  
  /**
   * Handles workflow created event
   * @private
   */
  private handleWorkflowCreated(): void {
    this.updateDiscoveryRegistration().catch(error => {
      this.getLogger().error('Failed to update discovery after workflow creation', { error });
    });
  }
  
  /**
   * Handles agent deleted event
   * @private
   */
  private handleAgentDeleted(): void {
    this.updateDiscoveryRegistration().catch(error => {
      this.getLogger().error('Failed to update discovery after agent deletion', { error });
    });
  }
  
  /**
   * Handles workflow deleted event
   * @private
   */
  private handleWorkflowDeleted(): void {
    this.updateDiscoveryRegistration().catch(error => {
      this.getLogger().error('Failed to update discovery after workflow deletion', { error });
    });
  }
  
  /**
   * Deregisters from the discovery service
   */
  async deregister(): Promise<void> {
    if (this.discoveryService && this.registered) {
      try {
        await this.discoveryService.deregisterProcess(this.processId);
        this.registered = false;
        
        this.getLogger().info('Process deregistered from discovery service', { 
          processId: this.processId 
        });
      } catch (error) {
        this.getLogger().error('Failed to deregister process from discovery service', { 
          processId: this.processId, 
          error 
        });
        throw error;
      }
    }
  }
  
  /**
   * Check if the task has been paid for by the given user
   * 
   * @param userWalletAddress The user's wallet address
   * @returns A promise that resolves to a boolean indicating if payment is verified
   */
  async verifyPayment(userWalletAddress: string): Promise<boolean> {
    // If no pricing is set, no payment is required
    if (!this.metadata.pricing) {
      return true;
    }
    
    // If prepayment is not required, no verification needed
    if (this.metadata.pricing.requiresPrepayment === false) {
      return true;
    }
    
    // If no payment service is set, we can't verify
    if (!this.paymentService) {
      this.getLogger().warn('Payment verification requested but no payment service provided', {
        processId: this.processId
      });
      return false;
    }
    
    // If no payment address is set, we can't verify
    if (!this.metadata.pricing.paymentAddress) {
      this.getLogger().warn('Payment verification requested but no payment address set', {
        processId: this.processId
      });
      return false;
    }
    
    // Verify payment using payment service
    const result = await this.paymentService.verifyPayment(
      userWalletAddress,
      this.processId,
      "task-default" // Default task ID if no specific task is specified
    );
    
    this.getLogger().info('Payment verification result', {
      processId: this.processId,
      userWallet: userWalletAddress,
      verified: result.verified,
      error: result.error
    });
    
    return result.verified;
  }
  
  /**
   * Get payment instructions for this process
   * 
   * @param userWalletAddress User's wallet address
   * @returns Payment instructions as a string
   */
  getPaymentInstructions(userWalletAddress: string): string {
    if (!this.metadata.pricing) {
      return 'This process does not require payment.';
    }
    
    if (!this.paymentService) {
      return 'Payment service not configured. Please contact the process owner.';
    }
    
    return this.paymentService.getPaymentInstructions(
      this.metadata.pricing as ProcessPricing,
      userWalletAddress
    );
  }
  
  /**
   * Run the process if payment is verified (if required)
   * 
   * @param userWalletAddress The wallet address of the user running the process
   */
  async runWithPaymentCheck(userWalletAddress: string): Promise<void> {
    // Check if payment is required and verified
    if (this.metadata.pricing?.requiresPrepayment) {
      const isPaid = await this.verifyPayment(userWalletAddress);
      if (!isPaid) {
        const requiredAmount = this.metadata.pricing.taskPrice;
        const currency = this.metadata.pricing.currency || 'APT';
        
        // Get payment instructions
        const instructions = this.getPaymentInstructions(userWalletAddress);
        
        throw new Error(
          `Payment required: ${requiredAmount} ${currency}. ` +
          `\n\n${instructions}`
        );
      }
    }
    
    // If payment is verified or not required, run the process
    await this.run();
  }
  
  /**
   * Starts running the process
   */
  async run(): Promise<void> {
    console.log(`Process ${this.processId} is running`);
    // Placeholder for actual process execution
  }
}

================
File: src/process/index.ts
================
export * from './extended-process';

================
File: src/transaction/transaction-handler.ts
================
import { AptosClient, AptosAccount, Types } from 'aptos';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';

import { ProcessDiscoveryService } from '../discovery/process-discovery-service';
import { PaymentService } from '../payment/payment-service';

/**
 * Transaction request interface
 */
export interface TransactionRequest {
  processId: string;
  userAddress: string;
  data: Record<string, any>;
  workflowId?: string;
  taskId?: string;
  priority?: number;
}

/**
 * Transaction response interface
 */
export interface TransactionResponse {
  transactionId: string;
  processId: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  result?: any;
  error?: string;
  timestamp: number;
}

/**
 * Transaction handler configuration
 */
export interface TransactionHandlerConfig {
  moduleAddress: string;
  aptosClient: AptosClient;
  paymentService: PaymentService;
  discoveryService: ProcessDiscoveryService;
}

/**
 * Transaction Handler 
 * 
 * Handles transaction requests and forwards them to agent processes.
 * Key responsibilities:
 * 1. Verify payment status for the requested process
 * 2. Register the transaction on the blockchain
 * 3. Forward the request to the agent process
 * 4. Update the transaction status on the blockchain
 */
export class TransactionHandler {
  private moduleAddress: string;
  private aptosClient: AptosClient;
  private paymentService: PaymentService;
  private discoveryService: ProcessDiscoveryService;
  
  constructor(config: TransactionHandlerConfig) {
    this.moduleAddress = config.moduleAddress;
    this.aptosClient = config.aptosClient;
    this.paymentService = config.paymentService;
    this.discoveryService = config.discoveryService;
  }
  
  /**
   * Handle a transaction request
   * 
   * @param request - Transaction request
   * @param account - Account to use for blockchain transactions
   * @returns Transaction response
   */
  public async handleTransaction(request: TransactionRequest, account: AptosAccount): Promise<TransactionResponse> {
    try {
      // Generate transaction ID
      const transactionId = uuidv4();
      
      // Create initial response
      const response: TransactionResponse = {
        transactionId,
        processId: request.processId,
        status: 'pending',
        timestamp: Date.now()
      };
      
      // Get process details
      const process = await this.discoveryService.getProcess(request.processId);
      if (!process) {
        response.status = 'failed';
        response.error = `Process not found: ${request.processId}`;
        return response;
      }
      
      // Verify payment if required
      if (process.pricing && process.pricing.requiresPrepayment) {
        const paymentVerified = await this.paymentService.verifyPayment(
          request.processId,
          request.userAddress
        );
        
        if (!paymentVerified) {
          response.status = 'failed';
          response.error = 'Payment required but not verified';
          return response;
        }
      }
      
      // Register transaction on blockchain
      await this.registerTransactionOnChain(account, {
        transactionId,
        processId: request.processId,
        userAddress: request.userAddress,
        workflowId: request.workflowId || '',
        taskId: request.taskId || '',
        status: 'pending'
      });
      
      // Update status to processing
      response.status = 'processing';
      await this.updateTransactionStatus(account, transactionId, 'processing');
      
      // Forward request to agent process
      try {
        const agentResponse = await this.forwardRequestToAgent(process.url, {
          transactionId,
          processId: request.processId,
          userAddress: request.userAddress,
          data: request.data,
          workflowId: request.workflowId,
          taskId: request.taskId,
          priority: request.priority || 1
        });
        
        // Update response with agent results
        response.status = 'completed';
        response.result = agentResponse.data;
        response.timestamp = Date.now();
        
        // Update transaction status on blockchain
        await this.updateTransactionStatus(account, transactionId, 'completed', agentResponse.data);
      } catch (error) {
        // Update response with error
        response.status = 'failed';
        response.error = error instanceof Error ? error.message : 'Unknown error during agent processing';
        response.timestamp = Date.now();
        
        // Update transaction status on blockchain
        await this.updateTransactionStatus(account, transactionId, 'failed', null, response.error);
      }
      
      return response;
    } catch (error) {
      // Handle unexpected errors
      return {
        transactionId: uuidv4(),
        processId: request.processId,
        status: 'failed',
        error: error instanceof Error ? error.message : 'Unknown error in transaction handling',
        timestamp: Date.now()
      };
    }
  }
  
  /**
   * Register a transaction on the blockchain
   * 
   * @param account - Account to use for the transaction
   * @param transaction - Transaction data
   */
  private async registerTransactionOnChain(
    account: AptosAccount,
    transaction: {
      transactionId: string;
      processId: string;
      userAddress: string;
      workflowId: string;
      taskId: string;
      status: string;
    }
  ): Promise<string> {
    try {
      const payload: Types.EntryFunctionPayload = {
        function: `${this.moduleAddress}::transaction_queue::register_transaction`,
        type_arguments: [],
        arguments: [
          transaction.transactionId,
          transaction.processId,
          transaction.userAddress,
          transaction.workflowId,
          transaction.taskId,
          transaction.status
        ]
      };
      
      const txnRequest = await this.aptosClient.generateTransaction(account.address(), payload);
      const signedTxn = await this.aptosClient.signTransaction(account, txnRequest);
      const pendingTxn = await this.aptosClient.submitTransaction(signedTxn);
      await this.aptosClient.waitForTransaction(pendingTxn.hash);
      
      return pendingTxn.hash;
    } catch (error) {
      throw new Error(`Failed to register transaction on blockchain: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Update transaction status on the blockchain
   * 
   * @param account - Account to use for the transaction
   * @param transactionId - Transaction ID
   * @param status - New status
   * @param result - Result data (optional)
   * @param error - Error message (optional)
   */
  private async updateTransactionStatus(
    account: AptosAccount,
    transactionId: string,
    status: string,
    result?: any,
    error?: string
  ): Promise<string> {
    try {
      const resultStr = result ? JSON.stringify(result) : '';
      const errorStr = error || '';
      
      const payload: Types.EntryFunctionPayload = {
        function: `${this.moduleAddress}::transaction_queue::update_transaction_status`,
        type_arguments: [],
        arguments: [
          transactionId,
          status,
          resultStr,
          errorStr
        ]
      };
      
      const txnRequest = await this.aptosClient.generateTransaction(account.address(), payload);
      const signedTxn = await this.aptosClient.signTransaction(account, txnRequest);
      const pendingTxn = await this.aptosClient.submitTransaction(signedTxn);
      await this.aptosClient.waitForTransaction(pendingTxn.hash);
      
      return pendingTxn.hash;
    } catch (error) {
      throw new Error(`Failed to update transaction status: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Forward request to agent process
   * 
   * @param agentUrl - URL of the agent process
   * @param request - Request data
   * @returns Response from the agent
   */
  private async forwardRequestToAgent(
    agentUrl: string,
    request: {
      transactionId: string;
      processId: string;
      userAddress: string;
      data: Record<string, any>;
      workflowId?: string;
      taskId?: string;
      priority?: number;
    }
  ): Promise<any> {
    try {
      // Ensure URL ends with a slash if it doesn't already
      const baseUrl = agentUrl.endsWith('/') ? agentUrl : `${agentUrl}/`;
      const url = `${baseUrl}execute`;
      
      // Forward the request
      const response = await axios.post(url, request, {
        headers: {
          'Content-Type': 'application/json'
        },
        timeout: 30000 // 30 second timeout
      });
      
      return response;
    } catch (error) {
      if (axios.isAxiosError(error)) {
        if (error.response) {
          throw new Error(`Agent process returned error: ${error.response.status} - ${JSON.stringify(error.response.data)}`);
        } else if (error.request) {
          throw new Error(`No response received from agent process: ${error.message}`);
        } else {
          throw new Error(`Error setting up request to agent process: ${error.message}`);
        }
      }
      throw error;
    }
  }
}

================
File: src/utils/constants.ts
================
/**
 * Default network to use if not specified
 */
export const DEFAULT_NETWORK = 'testnet';

/**
 * Default explorer URL format
 * Use with: format(EXPLORER_URL_FORMAT, network, address)
 */
export const EXPLORER_URL_FORMAT = 'https://%s.aptos.dev/account/%s';

/**
 * Default currency if not specified
 */
export const DEFAULT_CURRENCY = 'APT';

================
File: src/utils/env-validator.ts
================
import * as dotenv from 'dotenv';

// Load environment variables once at the module level
dotenv.config();

/**
 * Validates required environment variables and returns them
 * @throws Error if any required variable is missing
 */
export function validateEnv() {
  const requiredVars = [
    'APTOS_PRIVATE_KEY',
    'APTOS_MODULE_ADDRESS'
  ];
  
  const missingVars = requiredVars.filter(varName => !process.env[varName]);
  
  if (missingVars.length > 0) {
    throw new Error(`Missing required environment variables: ${missingVars.join(', ')}`);
  }
  
  return {
    privateKey: process.env.APTOS_PRIVATE_KEY!,
    moduleAddress: process.env.APTOS_MODULE_ADDRESS!,
    network: process.env.APTOS_NETWORK || 'testnet',
    nodeUrl: process.env.APTOS_NODE_URL,
    faucetUrl: process.env.APTOS_FAUCET_URL
  };
}

================
File: src/utils/index.ts
================
export * from './env-validator';
export * from './logger';
export * from './constants';

================
File: src/utils/logger.ts
================
/**
 * Standardized logger to ensure consistent output formatting across the application
 */
export class Logger {
  private context: string;

  constructor(context: string) {
    this.context = context;
  }

  /**
   * Log an info message
   */
  info(message: string): void {
    console.log(`ℹ️ [${this.context}] ${message}`);
  }

  /**
   * Log a success message
   */
  success(message: string): void {
    console.log(`✅ [${this.context}] ${message}`);
  }

  /**
   * Log an error message
   */
  error(message: string, error?: unknown): void {
    console.error(`❌ [${this.context}] ${message}`);
    if (error instanceof Error) {
      console.error(`  ${error.message}`);
      if (error.stack) {
        console.error(`  ${error.stack.split('\n').slice(1).join('\n')}`);
      }
    } else if (error) {
      console.error(`  ${error}`);
    }
  }

  /**
   * Log a warning message
   */
  warn(message: string): void {
    console.warn(`⚠️ [${this.context}] ${message}`);
  }

  /**
   * Log a section header
   */
  section(title: string): void {
    console.log(`\n🔹 ${title}`);
    console.log('─'.repeat(title.length + 3));
  }

  /**
   * Log a detail line (intended for use in details sections)
   */
  detail(label: string, value: string): void {
    console.log(`  ${label}: ${value}`);
  }
}

================
File: src/factories.ts
================
import { AptosContractService } from './contract/aptos-contract-service';
import { ContractService } from './contract/interfaces';
import { createAptosDiscoveryService } from './discovery';
import { DiscoveryService } from './discovery/interfaces';
import { AptosPaymentService } from './payment/aptos-payment-service';
import { PaymentService } from './payment/interfaces';
import { validateEnv } from './utils';

/**
 * Create an Aptos Contract Service from environment variables
 * 
 * @returns ContractService instance
 */
export function createAptosContractService(): ContractService {
  const env = validateEnv();
  
  return new AptosContractService({
    network: env.network,
    moduleAddress: env.moduleAddress,
    privateKey: env.privateKey,
    nodeUrl: env.nodeUrl,
    faucetUrl: env.faucetUrl
  });
}

/**
 * Create an Aptos Payment Service from environment variables
 * 
 * @param contractService Optional contract service to use
 * @returns PaymentService instance
 */
export function createAptosPaymentService(contractService?: ContractService): PaymentService {
  const env = validateEnv();
  const contractSvc = contractService || createAptosContractService();
  
  return new AptosPaymentService({
    moduleAddress: env.moduleAddress,
    aptosClient: contractSvc.getAptosClient()
  });
}

/**
 * Create an instance with both discovery and payment services
 * 
 * @returns Object containing discovery and payment services
 */
export function createAptosServices(): {
  discoveryService: DiscoveryService;
  paymentService: PaymentService;
  contractService: ContractService;
} {
  validateEnv();
  
  // Create services in a way that avoids multiple instances
  const contractService = createAptosContractService();
  const paymentService = createAptosPaymentService(contractService);
  const discoveryService = createAptosDiscoveryService();
  
  return {
    discoveryService,
    paymentService,
    contractService
  };
}

================
File: src/index.ts
================
/**
 * a3 Platform
 * 
 * Extensions to a2 core with platform capabilities including:
 * - Discovery services with Aptos blockchain integration
 * - Extended process with discovery registration
 * - Creator profile management
 * - Payment verification and processing
 * - Contract deployment and interaction
 */

// Export platform-specific modules
export * from './discovery';
export * from './process';

// Export new modules
export * from './creator/interfaces';
export * from './payment/interfaces';
export * from './payment/aptos-payment-service';
export * from './contract/interfaces';
export * from './contract/aptos-contract-service';

// Factory functions
export * from './factories';

// Utilities
export * from './utils';

// CLI
export * from './cli';

// Add additional platform modules here as they are developed

================
File: .eslintrc.js
================
module.exports = {
  env: {
    node: true,
    browser: true,
    es2021: true
  },
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended'
  ],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module'
  },
  plugins: ['@typescript-eslint'],
  rules: {
    // Add custom rules here
  }
};

================
File: .gitignore
================
# Dependencies
node_modules/
.pnp
.pnp.js

# Build outputs
dist/
build/
lib/
out/

# TypeScript
*.tsbuildinfo

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Editor directories and files
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# Testing
coverage/

# Database files
*.db
*.sqlite
*.sqlite3

================
File: deploy-contract.ts
================
#!/usr/bin/env node

/**
 * Deploy Aptos Smart Contract
 * 
 * This script deploys a smart contract to the Aptos blockchain
 * using the contract service.
 */

import * as fs from 'fs';
import * as path from 'path';

import * as dotenv from 'dotenv';

import { createAptosContractService } from './src';

// Load environment variables
dotenv.config();

/**
 * Deploy a contract to the Aptos blockchain
 * 
 * @param contractPath Path to the contract file
 */
async function deployContract(contractPath: string): Promise<void> {
  console.log('🚀 A3 Contract Deployment');
  console.log('=======================');
  
  // Check if contract file exists
  if (!fs.existsSync(contractPath)) {
    throw new Error(`Contract file not found: ${contractPath}`);
  }
  
  // Check for required environment variables
  if (!process.env.APTOS_PRIVATE_KEY) {
    throw new Error('APTOS_PRIVATE_KEY environment variable is required');
  }
  
  if (!process.env.APTOS_MODULE_ADDRESS) {
    throw new Error('APTOS_MODULE_ADDRESS environment variable is required');
  }
  
  try {
    console.log('1. Creating Aptos contract service...');
    // Create the contract service using factory function
    const contractService = createAptosContractService();
    console.log('✅ Contract service created');
    
    // Get contract details
    const contractName = path.basename(contractPath, path.extname(contractPath));
    const contractDir = path.dirname(contractPath);
    
    console.log(`2. Deploying contract ${contractName}...`);
    console.log(`    Path: ${contractPath}`);
    console.log(`    Network: ${process.env.APTOS_NETWORK || 'testnet'}`);
    console.log(`    Module Address: ${process.env.APTOS_MODULE_ADDRESS}`);
    
    // Deploy the contract
    const result = await contractService.deployContract(contractPath);
    
    if (result.success) {
      console.log('✅ Contract deployed successfully');
      if (result.transactionHash) {
        console.log(`    Transaction Hash: ${result.transactionHash}`);
      }
      console.log(`    Module Address: ${result.moduleAddress}`);
      console.log(`    Timestamp: ${result.timestamp}`);
      
      // Print explorer link
      const network = process.env.APTOS_NETWORK || 'testnet';
      console.log('\nView your contract on the Aptos Explorer:');
      console.log(`https://${network}.aptos.dev/account/${result.moduleAddress}`);
    } else {
      console.error('❌ Contract deployment failed');
      if (result.error) {
        console.error(`    Error: ${result.error}`);
      }
    }
  } catch (error) {
    console.error('Contract deployment failed:', error);
    throw error;
  }
}

// Parse command line arguments
let contractPath: string | undefined = undefined;
let i = 0;
const args = process.argv.slice(2);
console.log('Command arguments:', args);

while (i < args.length) {
  if (args[i] === '--path' || args[i] === '-p') {
    if (i + 1 < args.length) {
      contractPath = args[i+1];
      i++;
    }
  } else if (!contractPath) {
    // If the argument isn't a flag, treat it as the path
    contractPath = args[i];
  }
  i++;
}

console.log('Contract path from args:', contractPath);

// Use current directory's Move.toml file if no path provided
if (!contractPath) {
  const defaultPath = path.join(process.cwd(), 'Move.toml');
  if (fs.existsSync(defaultPath)) {
    contractPath = defaultPath;
  } else {
    throw new Error('No contract path provided and no Move.toml found in current directory');
  }
}

// Ensure the path exists
if (!fs.existsSync(contractPath)) {
  // If the path doesn't exist, try to add .toml extension or check if it's a directory
  if (fs.existsSync(`${contractPath}.toml`)) {
    contractPath = `${contractPath}.toml`;
  } else if (fs.existsSync(path.join(contractPath, 'Move.toml'))) {
    contractPath = path.join(contractPath, 'Move.toml');
  } else {
    throw new Error(`Contract file not found: ${contractPath}`);
  }
}

console.log('Final contract path:', contractPath);

// Run the deployment if executed directly
if (require.main === module) {
  deployContract(contractPath)
    .then((result) => {
      console.log('Deployment result:', JSON.stringify(result, null, 2));
      
      // Get path to Move.toml
      const movePath = path.resolve(contractPath);
      console.log('Move path:', movePath);
      
      // Display environment variables
      console.log('Environment variables:');
      console.log('- APTOS_PRIVATE_KEY:', process.env.APTOS_PRIVATE_KEY?.substring(0, 8) + '...');
      console.log('- APTOS_MODULE_ADDRESS:', process.env.APTOS_MODULE_ADDRESS);
      console.log('- APTOS_NETWORK:', process.env.APTOS_NETWORK);
      console.log('- APTOS_NODE_URL:', process.env.APTOS_NODE_URL);
      
      // Try to run a direct CLI command for diagnostic purposes
      const { exec } = require('child_process');
      console.log('\nRunning direct Aptos CLI command for diagnostics:');
      exec('aptos account list', (error: Error | null, stdout: string, stderr: string) => {
        console.log('Aptos CLI output:', stdout);
        if (error || stderr) {
          console.error('Aptos CLI error:', error || stderr);
        }
        process.exit(0);
      });
    })
    .catch(error => {
      console.error('Deployment failed:', error);
      process.exit(1);
    });
}

export { deployContract };

================
File: get-process.ts
================
#!/usr/bin/env node

/**
 * Get A3 Process from Aptos Blockchain
 * 
 * This script retrieves and displays a specific process
 * from the Aptos blockchain using the A3 discovery service.
 */

import * as dotenv from 'dotenv';

import { createAptosDiscoveryService } from './src';

// Load environment variables
dotenv.config();

/**
 * Get a specific process from the Aptos blockchain by ID
 */
async function getProcess(processId: string) {
  console.log('🔍 A3 Process Lookup');
  console.log('==================');
  
  // Check for required environment variables
  if (!process.env.APTOS_PRIVATE_KEY) {
    throw new Error('APTOS_PRIVATE_KEY environment variable is required');
  }
  
  if (!process.env.APTOS_MODULE_ADDRESS) {
    throw new Error('APTOS_MODULE_ADDRESS environment variable is required');
  }
  
  if (!processId) {
    throw new Error('Process ID is required');
  }
  
  try {
    console.log('1. Creating Aptos discovery service...');
    // Create the discovery service using factory function
    const discoveryService = createAptosDiscoveryService();
    console.log('✅ Discovery service created');
    
    console.log(`2. Retrieving process ${processId} from blockchain...`);
    // Get the specific process by ID
    const processData = await discoveryService.getProcess(processId);
    
    if (!processData) {
      console.log(`\n❌ Process with ID "${processId}" not found.`);
      return {
        success: false,
        message: 'Process not found'
      };
    }
    
    console.log('✅ Process found');
    
    // Display process details
    console.log('\nProcess Details:');
    console.log('--------------');
    console.log(`ID: ${processData.id}`);
    console.log(`Name: ${processData.name}`);
    console.log(`Description: ${processData.description}`);
    console.log(`Owner: ${processData.owner}`);
    console.log(`Status: ${processData.status}`);
    console.log(`Created: ${new Date(processData.createdAt).toLocaleString()}`);
    console.log(`Updated: ${new Date(processData.updatedAt).toLocaleString()}`);
    
    if (processData.tags && processData.tags.length > 0) {
      console.log(`Tags: ${processData.tags.join(', ')}`);
    }
    
    // Get network and module address from environment variables
    const network = process.env.APTOS_NETWORK || 'testnet';
    const moduleAddress = process.env.APTOS_MODULE_ADDRESS;
    
    console.log('\n🔗 View on Aptos Explorer:');
    console.log(`https://${network}.aptos.dev/account/${moduleAddress}`);
    
    return {
      success: true,
      process: processData
    };
  } catch (error) {
    console.error('Process lookup failed:', error);
    throw error;
  }
}

// Get process ID from command line arguments
const processId = process.argv[2];

// Run the process lookup if this script is executed directly
if (require.main === module) {
  getProcess(processId)
    .then(() => process.exit(0))
    .catch(error => {
      console.error('Lookup failed:', error);
      process.exit(1);
    });
}

export { getProcess };

================
File: list-processes.ts
================
#!/usr/bin/env node

/**
 * List A3 Processes on Aptos Blockchain
 * 
 * This script retrieves and displays all processes registered
 * on the Aptos blockchain via the A3 discovery service.
 */

import * as dotenv from 'dotenv';

import { createAptosDiscoveryService } from './src';

// Load environment variables
dotenv.config();

/**
 * List all processes registered on the Aptos blockchain
 */
async function listAllProcesses(filterTags?: string[]) {
  console.log('📋 A3 Process Listing');
  console.log('===================');
  
  // Check for required environment variables
  if (!process.env.APTOS_PRIVATE_KEY) {
    throw new Error('APTOS_PRIVATE_KEY environment variable is required');
  }
  
  if (!process.env.APTOS_MODULE_ADDRESS) {
    throw new Error('APTOS_MODULE_ADDRESS environment variable is required');
  }
  
  try {
    console.log('1. Creating Aptos discovery service...');
    // Create the discovery service using factory function
    const discoveryService = createAptosDiscoveryService();
    console.log('✅ Discovery service created');
    
    console.log('2. Retrieving processes from blockchain...');
    // Create query filters if tags are provided
    const filters = filterTags && filterTags.length > 0 ? { tags: filterTags } : undefined;
    
    // List processes with optional filters
    const processes = await discoveryService.listProcesses(filters);
    
    console.log(`✅ Retrieved ${processes.length} processes`);
    
    if (processes.length === 0) {
      console.log('\nNo processes found.');
      if (filterTags && filterTags.length > 0) {
        console.log(`No processes matched the tags: ${filterTags.join(', ')}`);
      }
    } else {
      console.log('\nRegistered Processes:');
      console.log('-------------------');
      
      // Display process details
      processes.forEach((process, index) => {
        console.log(`\n[${index + 1}] Process ID: ${process.id}`);
        console.log(`    Name: ${process.name}`);
        console.log(`    Description: ${process.description}`);
        console.log(`    Owner: ${process.owner}`);
        console.log(`    Status: ${process.status}`);
        console.log(`    Created: ${new Date(process.createdAt).toLocaleString()}`);
        console.log(`    Updated: ${new Date(process.updatedAt).toLocaleString()}`);
        if (process.tags && process.tags.length > 0) {
          console.log(`    Tags: ${process.tags.join(', ')}`);
        }
        
        // Display creator profile if available
        if (process.creatorProfile) {
          console.log(`    Creator Profile:`);
          if (process.creatorProfile.name) {
            console.log(`      Name: ${process.creatorProfile.name}`);
          }
          if (process.creatorProfile.description) {
            console.log(`      Description: ${process.creatorProfile.description}`);
          }
          if (process.creatorProfile.walletAddress) {
            console.log(`      Wallet: ${process.creatorProfile.walletAddress}`);
          }
          if (process.creatorProfile.website) {
            console.log(`      Website: ${process.creatorProfile.website}`);
          }
          if (process.creatorProfile.social && Object.keys(process.creatorProfile.social).length > 0) {
            console.log(`      Social:`);
            for (const [platform, url] of Object.entries(process.creatorProfile.social)) {
              console.log(`        ${platform}: ${url}`);
            }
          }
        }
        
        // Display pricing information if available
        if (process.pricing) {
          console.log(`    Pricing:`);
          console.log(`      Task Price: ${process.pricing.taskPrice} ${process.pricing.currency || 'APT'}`);
          if (process.pricing.paymentAddress) {
            console.log(`      Payment Address: ${process.pricing.paymentAddress}`);
          }
          console.log(`      Requires Prepayment: ${process.pricing.requiresPrepayment ? 'Yes' : 'No'}`);
        }
      });
    }
    
    // Get network and module address from environment variables
    const network = process.env.APTOS_NETWORK || 'testnet';
    const moduleAddress = process.env.APTOS_MODULE_ADDRESS;
    
    console.log('\n📊 View all processes on the Aptos Explorer:');
    console.log(`https://${network}.aptos.dev/account/${moduleAddress}`);
    
    return {
      success: true,
      count: processes.length,
      processes
    };
  } catch (error) {
    console.error('Failed to list processes:', error);
    throw error;
  }
}

// Parse command line arguments
const args = process.argv.slice(2);
let filterTags: string[] | undefined;

// Parse simple command-line arguments
for (let i = 0; i < args.length; i++) {
  if (args[i] === '--tags' && args[i+1]) {
    filterTags = args[i+1].split(',');
    i++;
  }
}

// Run the listing if this script is executed directly
if (require.main === module) {
  listAllProcesses(filterTags)
    .then(() => process.exit(0))
    .catch(error => {
      console.error('Listing failed:', error);
      process.exit(1);
    });
}

export { listAllProcesses };

================
File: package.json
================
{
  "name": "@a3/platform",
  "version": "0.1.0",
  "description": "a3 platform - Extensions to a2 with platform capabilities including service discovery",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "bin": {
    "a3": "dist/bin/a3.js",
    "a3-register-process": "dist/register-process.js"
  },
  "scripts": {
    "build": "tsc",
    "start": "ts-node server.ts",
    "test": "jest",
    "lint": "eslint 'src/**/*.ts'",
    "cli": "ts-node src/bin/a3.ts",
    "aptos:setup": "ts-node src/discovery/aptos/setup.ts",
    "aptos:deploy": "ts-node src/discovery/aptos/deploy-contract.ts",
    "aptos:test": "ts-node src/discovery/aptos/test-contract.ts",
    "aptos:example": "ts-node src/discovery/aptos/example-client.ts",
    "aptos:process-example": "ts-node src/examples/aptos-process-example.ts"
  },
  "keywords": [
    "ai",
    "agent",
    "platform",
    "discovery",
    "aptos",
    "blockchain",
    "typescript"
  ],
  "author": "Onur Akdeniz <onurakdeniz@outlook.com>",
  "license": "MIT",
  "dependencies": {
    "@aptos-labs/ts-sdk": "^1.36.0",
    "aptos": "^1.21.0",
    "axios": "^1.8.4",
    "commander": "^13.1.0",
    "cors": "^2.8.5",
    "dotenv": "catalog:",
    "express": "^4.18.2",
    "inquirer": "^12.5.0",
    "uuid": "catalog:",
    "zod": "catalog:"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/inquirer": "^9.0.7",
    "@types/jest": "^29.5.12",
    "@types/node": "catalog:",
    "@types/uuid": "^9.0.7",
    "eslint": "catalog:",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "jest": "catalog:",
    "prettier": "catalog:",
    "ts-jest": "catalog:",
    "ts-node": "^10.9.2",
    "typescript": "catalog:"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}

================
File: register-process.ts
================
#!/usr/bin/env node

/**
 * A3 Process Registration Script
 * 
 * This script allows you to register a process
 * with the Aptos blockchain via the A3 discovery service.
 * It supports creator profiles and pricing information.
 */

import { Command } from 'commander';

import { registerProcess } from './src/cli/register-process-command';

// Run the command if this script is executed directly
if (require.main === module) {
  const program = new Command()
    .name('register-process')
    .description('Register a process with the Aptos blockchain')
    .option('--name <name>', 'Name of the process', 'Custom Process')
    .option('--description <description>', 'Description of the process', 'A process registered with A3 on Aptos')
    .option('--tags <tags>', 'Comma-separated list of tags', (val) => val.split(','), [])
    .option('--creator-name <name>', 'Name of the creator')
    .option('--creator-description <description>', 'Description of the creator')
    .option('--creator-wallet <address>', 'Wallet address of the creator')
    .option('--creator-website <url>', 'Website of the creator')
    .option('--creator-social <socials>', 'Comma-separated list of social media links in format platform:url')
    .option('--task-price <price>', 'Price for a task')
    .option('--currency <currency>', 'Currency for the task price', 'APT')
    .option('--payment-address <address>', 'Address to receive payments')
    .option('--requires-prepayment <boolean>', 'Whether the process requires prepayment', (val) => val === 'true', true)
    .action(async (options) => {
      try {
        // Parse creator profile if provided
        let creatorProfile: any = undefined;
        if (options.creatorName || options.creatorDescription || options.creatorWallet || options.creatorWebsite || options.creatorSocial) {
          creatorProfile = {};
          
          if (options.creatorName) creatorProfile.name = options.creatorName;
          if (options.creatorDescription) creatorProfile.description = options.creatorDescription;
          if (options.creatorWallet) creatorProfile.walletAddress = options.creatorWallet;
          if (options.creatorWebsite) creatorProfile.website = options.creatorWebsite;
          
          if (options.creatorSocial) {
            creatorProfile.social = {};
            const socialParts = options.creatorSocial.split(',');
            for (const part of socialParts) {
              const [platform, url] = part.split(':');
              if (platform && url && creatorProfile.social) {
                creatorProfile.social[platform] = url;
              }
            }
          }
        }
        
        // Parse pricing if provided
        let pricing: any = undefined;
        if (options.taskPrice) {
          pricing = {
            taskPrice: options.taskPrice,
            currency: options.currency,
            paymentAddress: options.paymentAddress,
            requiresPrepayment: options.requiresPrepayment
          };
        }
        
        // Register the process
        await registerProcess(
          options.name,
          options.description,
          options.tags,
          creatorProfile,
          pricing
        );
      } catch (error) {
        console.error('Registration failed:', error);
        process.exit(1);
      }
    });
  
  program.parse(process.argv);
}

export { registerProcess };

================
File: run-process-with-payment.ts
================
#!/usr/bin/env node

/**
 * Run A3 Process with Payment Verification
 * 
 * This script demonstrates how to run a process with payment verification
 * for the Aptos blockchain. It will check if payment has been made
 * before executing the process.
 */

import * as dotenv from 'dotenv';

import { createAptosServices, ExtendedProcess } from './src';

// Load environment variables
dotenv.config();

/**
 * Run a process with payment verification
 * 
 * @param processId The ID of the process to run
 * @param userWalletAddress The wallet address of the user running the process
 */
async function runProcessWithPayment(processId: string, userWalletAddress: string): Promise<void> {
  console.log('🚀 A3 Process Execution with Payment Verification');
  console.log('===============================================');
  
  // Check for required environment variables
  if (!process.env.APTOS_PRIVATE_KEY) {
    throw new Error('APTOS_PRIVATE_KEY environment variable is required');
  }
  
  if (!process.env.APTOS_MODULE_ADDRESS) {
    throw new Error('APTOS_MODULE_ADDRESS environment variable is required');
  }
  
  try {
    console.log('1. Creating Aptos services...');
    // Create the services using factory function
    const { discoveryService, paymentService } = createAptosServices();
    console.log('✅ Services created');
    
    console.log(`2. Retrieving process ${processId}...`);
    // Get the process metadata from the discovery service
    const processMetadata = await discoveryService.getProcess(processId);
    
    if (!processMetadata) {
      throw new Error(`Process with ID ${processId} not found`);
    }
    
    console.log('✅ Process found');
    console.log(`    Name: ${processMetadata.name}`);
    console.log(`    Description: ${processMetadata.description}`);
    
    // Check if the process requires payment
    if (processMetadata.pricing) {
      console.log(`    Price: ${processMetadata.pricing.taskPrice} ${processMetadata.pricing.currency || 'APT'}`);
      console.log(`    Requires Prepayment: ${processMetadata.pricing.requiresPrepayment ? 'Yes' : 'No'}`);
      if (processMetadata.pricing.paymentAddress) {
        console.log(`    Payment Address: ${processMetadata.pricing.paymentAddress}`);
      }
    } else {
      console.log('    No pricing information available (process is free to use)');
    }
    
    // Check if the process has a creator profile
    if (processMetadata.creatorProfile) {
      console.log('    Creator Information:');
      if (processMetadata.creatorProfile.name) {
        console.log(`      Creator: ${processMetadata.creatorProfile.name}`);
      }
      if (processMetadata.creatorProfile.walletAddress) {
        console.log(`      Creator Wallet: ${processMetadata.creatorProfile.walletAddress}`);
      }
    }
    
    // Create an ExtendedProcess instance from the metadata
    console.log('3. Creating process instance...');
    const process = new ExtendedProcess({
      discoveryService,
      paymentService,
      metadata: {
        name: processMetadata.name,
        description: processMetadata.description,
        tags: processMetadata.tags,
        owner: processMetadata.owner,
        creatorProfile: processMetadata.creatorProfile,
        pricing: processMetadata.pricing
      }
    });
    
    console.log('✅ Process instance created');
    
    // Run the process with payment verification
    console.log('4. Verifying payment and running process...');
    console.log(`    User wallet: ${userWalletAddress}`);
    
    try {
      await process.runWithPaymentCheck(userWalletAddress);
      console.log('✅ Process execution successful');
    } catch (error) {
      if (error instanceof Error && error.message.includes('Payment required')) {
        console.error('❌ Payment verification failed');
        console.error(error.message);
      } else {
        throw error;
      }
    }
  } catch (error) {
    console.error('Process execution failed:', error);
    throw error;
  }
}

// Parse command line arguments
const args = process.argv.slice(2);
let processId: string | undefined;
let userWalletAddress: string | undefined;

// Parse simple command-line arguments
for (let i = 0; i < args.length; i++) {
  if (args[i] === '--process-id' && args[i+1]) {
    processId = args[i+1];
    i++;
  } else if (args[i] === '--user-wallet' && args[i+1]) {
    userWalletAddress = args[i+1];
    i++;
  }
}

// Check for required arguments
if (!processId || !userWalletAddress) {
  const missingArgs = [];
  if (!processId) missingArgs.push('--process-id');
  if (!userWalletAddress) missingArgs.push('--user-wallet');
  
  throw new Error(`Missing required arguments: ${missingArgs.join(', ')}`);
}

// Run the process with payment verification if executed directly
if (require.main === module) {
  runProcessWithPayment(processId, userWalletAddress)
    .then(() => process.exit(0))
    .catch(error => {
      console.error('Execution failed:', error);
      process.exit(1);
    });
}

export { runProcessWithPayment };

================
File: server.ts
================
import * as dotenv from 'dotenv';

import { CustomAgentGatewayServer } from './src/api/custom-agent-gateway';

// Load environment variables
dotenv.config();

// Create and start the gateway server
const defaultPort = parseInt(process.env.PORT || '3000');
let port = defaultPort;
const alternativePorts = [3001, 3002, 3003, 3004, 3005];
const moduleAddress = process.env.APTOS_MODULE_ADDRESS;
const aptosNetwork = process.env.APTOS_NETWORK || 'testnet';
const privateKey = process.env.APTOS_PRIVATE_KEY;

// Try to start the server with fallback to alternative ports if needed
function tryStart(portToTry: number, portIndex = 0) {
  // Validate that required environment variables are available
  if (!moduleAddress) {
    console.error('APTOS_MODULE_ADDRESS environment variable is required');
    process.exit(1);
  }

  if (!privateKey) {
    console.error('APTOS_PRIVATE_KEY environment variable is required');
    process.exit(1);
  }

  // Create a new server instance with the current port
  const serverInstance = new CustomAgentGatewayServer({
    port: portToTry,
    moduleAddress: moduleAddress as string,
    aptosNetwork,
    privateKey: privateKey as string
  });

  try {
    // Use a regular Node.js server to test if port is available
    const http = require('http');
    const testServer = http.createServer();
    
    testServer.once('error', (err: any) => {
      if (err.code === 'EADDRINUSE') {
        console.log(`Port ${portToTry} is already in use.`);
        testServer.close();
        
        if (portIndex < alternativePorts.length) {
          const nextPort = alternativePorts[portIndex];
          console.log(`Trying alternative port ${nextPort}...`);
          tryStart(nextPort, portIndex + 1);
        } else {
          console.error('All ports are in use. Please free up a port or specify a different port with the PORT environment variable.');
          process.exit(1);
        }
      } else {
        console.error('Server error:', err);
        process.exit(1);
      }
    });
    
    testServer.once('listening', () => {
      // Port is available, close test server and start the real one
      testServer.close(() => {
        serverInstance.start();
        console.log('Server starting on port', portToTry);
        console.log(`Note: The SDK should be configured with apiUrl: 'http://localhost:${portToTry}/api'`);
      });
    });
    
    testServer.listen(portToTry);
  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
}

tryStart(port);

================
File: setup-aptos.sh
================
#!/bin/bash

# Complete Aptos setup script for a3 platform
echo "🚀 Setting up Aptos for a3 platform"

# Generate a private key if not already created
if [ ! -f "aptos-key.txt" ]; then
  echo "Generating private key..."
  aptos key generate --output-file aptos-key.txt
fi

PRIVATE_KEY=$(cat aptos-key.txt)
PUBLIC_KEY=$(cat aptos-key.txt.pub)
echo "Private key: $PRIVATE_KEY"
echo "Public key: $PUBLIC_KEY"

# Create a profile file for aptos CLI with non-interactive setup
mkdir -p $HOME/.aptos

APTOS_CONFIG="$HOME/.aptos/config.yaml"
echo "Creating Aptos CLI config..."
cat > $APTOS_CONFIG << EOF
---
profiles:
  default:
    private_key: "0x$PRIVATE_KEY"
    public_key: "$PUBLIC_KEY"
    account: null
    rest_url: "https://fullnode.testnet.aptoslabs.com/v1"
    faucet_url: "https://faucet.testnet.aptoslabs.com"
EOF

echo "Deriving account address..."
ADDRESS_OUTPUT=$(aptos account derive-resource-account-address --seed 12345 | grep "Resource account address")
ACCOUNT_ADDRESS=$(echo $ADDRESS_OUTPUT | awk '{print $4}')
echo "Account address: $ACCOUNT_ADDRESS"

# Update the config with account
sed -i '' "s/account: null/account: \"$ACCOUNT_ADDRESS\"/" $APTOS_CONFIG

# Create the .env file
echo "Creating .env file..."
cat > .env << EOF
# Aptos Configuration
APTOS_PRIVATE_KEY=$PRIVATE_KEY
APTOS_NETWORK=testnet
APTOS_ACCOUNT_ADDRESS=$ACCOUNT_ADDRESS
EOF

# Copy the environment file to packages/a3
echo "Copying .env to packages/a3..."
cp .env packages/a3/.env

# Deploy the Move module
echo "Deploying the process registry contract..."
cd packages/a3
mkdir -p src/discovery/aptos/build

echo "Compiling Move module..."
aptos move compile --package-dir src/discovery/aptos --output-dir src/discovery/aptos/build --named-addresses process_registry=$ACCOUNT_ADDRESS

echo "Publishing Move module..."
PUBLISH_OUTPUT=$(aptos move publish --package-dir src/discovery/aptos --named-addresses process_registry=$ACCOUNT_ADDRESS)
echo "$PUBLISH_OUTPUT"

# Extract transaction hash
TX_HASH=$(echo "$PUBLISH_OUTPUT" | grep "transaction hash" | awk '{print $3}')
echo "Transaction hash: $TX_HASH"

# Initialize the registry
echo "Initializing the registry..."
INIT_OUTPUT=$(aptos move run --function-id ${ACCOUNT_ADDRESS}::process_registry::initialize)
echo "$INIT_OUTPUT"

# Update the .env file with the module address
echo "Updating .env file with module address..."
cd ../..
cat > .env << EOF
# Aptos Configuration
APTOS_PRIVATE_KEY=$PRIVATE_KEY
APTOS_NETWORK=testnet
APTOS_MODULE_ADDRESS=$ACCOUNT_ADDRESS
EOF

cp .env packages/a3/.env

echo "✅ Setup complete!"
echo "Your Aptos account is now set up and the Process Registry contract is deployed."
echo "Private key: $PRIVATE_KEY"
echo "Account/Module address: $ACCOUNT_ADDRESS"
echo ""
echo "Next step: Register your process with:"
echo "cd packages/a3 && pnpm run aptos:process-example"

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "outDir": "./dist",
    "strict": true,
    "declaration": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*", "*.ts"],
  "exclude": ["node_modules", "**/*.test.ts"]
}



================================================================
End of Codebase
================================================================
